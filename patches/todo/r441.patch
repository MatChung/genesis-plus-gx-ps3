Index: source/sound/ym2612.c
===================================================================
--- source/sound/ym2612.c	(revision 440)
+++ source/sound/ym2612.c	(revision 441)
@@ -2028,7 +2028,7 @@
 }
 
 /* Generate 16 bits samples for ym2612 */
-void YM2612Update(INT32 *buffer, int length)
+void YM2612Update(long int *buffer, int length)
 {
   int i;
   long int lt,rt;
Index: source/sound/ym2612.h
===================================================================
--- source/sound/ym2612.h	(revision 440)
+++ source/sound/ym2612.h	(revision 441)
@@ -21,7 +21,7 @@
 
 extern int YM2612Init(float clock, int rate);
 extern int YM2612ResetChip(void);
-extern void YM2612Update(INT32 *buffer, int length);
+extern void YM2612Update(long int *buffer, int length);
 extern void YM2612Write(unsigned int a, unsigned int v);
 extern unsigned int YM2612Read(void);
 extern unsigned char *YM2612GetContextPtr(void);
Index: source/gx/vi_encoder.c
===================================================================
--- source/gx/vi_encoder.c	(revision 440)
+++ source/gx/vi_encoder.c	(revision 441)
@@ -1,549 +0,0 @@
-/****************************************************************************
- *  vi_encoder.c
- *
- *  Wii Audio/Video Encoder support
- *
- *  Copyright (C) 2009 Hector Martin (marcan)
- *  Additional code by Eke-Eke
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- ***************************************************************************/
-#if defined(HW_RVL)
-
-#include <string.h>
-#include <gccore.h>
-#include <ogcsys.h>
-#include <ogc/machine/processor.h>
-
-#include "vi_encoder.h"
-
-/****************************************************************************
- *  I2C driver by Hector Martin (marcan)
- *
- ****************************************************************************/
-
-#define _SHIFTL(v, s, w)	\
-    ((u32) (((u32)(v) & ((0x01 << (w)) - 1)) << (s)))
-#define _SHIFTR(v, s, w)	\
-    ((u32)(((u32)(v) >> (s)) & ((0x01 << (w)) - 1)))
-
-extern void udelay(int us);
-
-static u32 i2cIdentFirst = 0;
-static u32 i2cIdentFlag = 1;
-static vu16* const _viReg = (u16*)0xCC002000;
-static vu32* const _i2cReg = (u32*)0xCD800000;
-
-static inline void __viOpenI2C(u32 channel)
-{
-	u32 val = ((_i2cReg[49]&~0x8000)|0x4000);
-	val |= _SHIFTL(channel,15,1);
-	_i2cReg[49] = val;
-}
-
-static inline u32 __viSetSCL(u32 channel)
-{
-	u32 val = (_i2cReg[48]&~0x4000);
-	val |= _SHIFTL(channel,14,1);
-	_i2cReg[48] = val;
-	return 1;
-}
-static inline u32 __viSetSDA(u32 channel)
-{
-	u32 val = (_i2cReg[48]&~0x8000);
-	val |= _SHIFTL(channel,15,1);
-	_i2cReg[48] = val;
-	return 1;
-}
-
-static inline u32 __viGetSDA()
-{
-	return _SHIFTR(_i2cReg[50],15,1);
-}
-
-static inline void __viCheckI2C()
-{
-	__viOpenI2C(0);
-	udelay(4);
-
-	i2cIdentFlag = 0;
-	if(__viGetSDA()!=0) i2cIdentFlag = 1;
-}
-
-static u32 __sendSlaveAddress(u8 addr)
-{
-	u32 i;
-
-	__viSetSDA(i2cIdentFlag^1);
-	udelay(2);
-
-	__viSetSCL(0);
-	for(i=0;i<8;i++) {
-		if(addr&0x80) __viSetSDA(i2cIdentFlag);
-		else __viSetSDA(i2cIdentFlag^1);
-		udelay(2);
-
-		__viSetSCL(1);
-		udelay(2);
-
-		__viSetSCL(0);
-		addr <<= 1;
-	}
-
-	__viOpenI2C(0);
-	udelay(2);
-
-	__viSetSCL(1);
-	udelay(2);
-
-	if(i2cIdentFlag==1 && __viGetSDA()!=0) return 0;
-
-	__viSetSDA(i2cIdentFlag^1);
-	__viOpenI2C(1);
-	__viSetSCL(0);
-
-	return 1;
-}
-
-static u32 __VISendI2CData(u8 addr,void *val,u32 len)
-{
-	u8 c;
-	s32 i,j;
-	u32 level,ret;
-
-	if(i2cIdentFirst==0) {
-		__viCheckI2C();
-		i2cIdentFirst = 1;
-	}
-
-	_CPU_ISR_Disable(level);
-
-	__viOpenI2C(1);
-	__viSetSCL(1);
-
-	__viSetSDA(i2cIdentFlag);
-	udelay(4);
-
-	ret = __sendSlaveAddress(addr);
-	if(ret==0) {
-		_CPU_ISR_Restore(level);
-		return 0;
-	}
-
-	__viOpenI2C(1);
-	for(i=0;i<len;i++) {
-		c = ((u8*)val)[i];
-		for(j=0;j<8;j++) {
-			if(c&0x80) __viSetSDA(i2cIdentFlag);
-			else __viSetSDA(i2cIdentFlag^1);
-			udelay(2);
-
-			__viSetSCL(1);
-			udelay(2);
-			__viSetSCL(0);
-
-			c <<= 1;
-		}
-		__viOpenI2C(0);
-		udelay(2);
-		__viSetSCL(1);
-		udelay(2);
-
-		if(i2cIdentFlag==1 && __viGetSDA()!=0) {
-			_CPU_ISR_Restore(level);
-			return 0;
-		}
-
-		__viSetSDA(i2cIdentFlag^1);
-		__viOpenI2C(1);
-		__viSetSCL(0);
-	}
-
-	__viOpenI2C(1);
-	__viSetSDA(i2cIdentFlag^1);
-	udelay(2);
-	__viSetSDA(i2cIdentFlag);
-
-	_CPU_ISR_Restore(level);
-	return 1;
-}
-
-static void __VIWriteI2CRegister8(u8 reg, u8 data)
-{
-	u8 buf[2];
-	buf[0] = reg;
-	buf[1] = data;
-	__VISendI2CData(0xe0,buf,2);
-	udelay(2);
-}
-
-static void __VIWriteI2CRegister16(u8 reg, u16 data)
-{
-	u8 buf[3];
-	buf[0] = reg;
-	buf[1] = data >> 8;
-	buf[2] = data & 0xFF;
-	__VISendI2CData(0xe0,buf,3);
-	udelay(2);
-}
-
-static void __VIWriteI2CRegister32(u8 reg, u32 data)
-{
-	u8 buf[5];
-	buf[0] = reg;
-	buf[1] = data >> 24;
-	buf[2] = (data >> 16) & 0xFF;
-	buf[3] = (data >> 8) & 0xFF;
-	buf[4] = data & 0xFF;
-	__VISendI2CData(0xe0,buf,5);
-	udelay(2);
-}
-
-static void __VIWriteI2CRegisterBuf(u8 reg, int size, u8 *data)
-{
-	u8 buf[0x100];
-	buf[0] = reg;
-	memcpy(&buf[1], data, size);
-	__VISendI2CData(0xe0,buf,size+1);
-	udelay(2);
-}
-
-/****************************************************************************
- *  A/V functions support (Eke-Eke)
- *
- ****************************************************************************/
-static const u8 gamma_coeffs[][33] =
-{
-	/* GM_0_0 */
-	{
-		 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
-		 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
- 
-	},	
- 
-	/* GM_0_1 */
-	{
-		 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x03, 0x97, 0x3B, 0x49,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x80, 0x1B, 0x80, 0xEB, 0x00
-	},	
- 
-	/* GM_0_2 */
-	{
-		 0x00, 0x00, 0x00, 0x28, 0x00, 0x5A, 0x02, 0xDB, 0x0D, 0x8D, 0x30, 0x49,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x10, 0x00, 0x10, 0x40, 0x11, 0x00, 0x18, 0x80, 0x42, 0x00, 0xEB, 0x00
-	},	
- 
-	/* GM_0_3 */
-	{
-		 0x00, 0x00, 0x00, 0x7A, 0x02, 0x3C, 0x07, 0x6D, 0x12, 0x9C, 0x27, 0x24,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x10, 0x00, 0x10, 0xC0, 0x15, 0x80, 0x29, 0x00, 0x62, 0x00, 0xEB, 0x00
-	},	
- 
-	/* GM_0_4 */
-	{
-		 0x00, 0x4E, 0x01, 0x99, 0x05, 0x2D, 0x0B, 0x24, 0x14, 0x29, 0x20, 0xA4,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x00, 0x10, 0x10, 0x40, 0x12, 0xC0, 0x1D, 0xC0, 0x3B, 0x00, 0x78, 0xC0, 0xEB, 0x00
-	},	
- 
-	/* GM_0_5 */
-	{
-		 0x00, 0xEC, 0x03, 0xD7, 0x08, 0x00, 0x0D, 0x9E, 0x14, 0x3E, 0x1B, 0xDB,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x10, 0xC0, 0x16, 0xC0, 0x27, 0xC0, 0x4B, 0x80, 0x89, 0x80, 0xEB, 0x00
-	},	
- 
-	/* GM_0_6 */
-	{
-		 0x02, 0x76, 0x06, 0x66, 0x0A, 0x96, 0x0E, 0xF3, 0x13, 0xAC, 0x18, 0x49,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB, 
-		 0x10, 0x00, 0x12, 0x00, 0x1C, 0x00, 0x32, 0x80, 0x59, 0xC0, 0x96, 0x00, 0xEB, 0x00
-	},	
- 
-	/* GM_0_7 */
-	{
-		 0x04, 0xEC, 0x08, 0xF5, 0x0C, 0x96, 0x0F, 0xCF, 0x12, 0xC6, 0x15, 0x80,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB, 
-		 0x10, 0x00, 0x14, 0x00, 0x22, 0x00, 0x3C, 0xC0, 0x66, 0x40, 0x9F, 0xC0, 0xEB, 0x00
-	},	
- 
-	/* GM_0_8 */
-	{
-		 0x08, 0x00, 0x0B, 0xAE, 0x0E, 0x00, 0x10, 0x30, 0x11, 0xCB, 0x13, 0x49,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB, 
-		 0x10, 0x00, 0x16, 0x80, 0x28, 0xC0, 0x46, 0x80, 0x71, 0x00, 0xA7, 0x80, 0xEB, 0x00
-	},	
- 
-	/* GM_0_9 */
-	{
-		 0x0B, 0xB1, 0x0E, 0x14, 0x0F, 0x2D, 0x10, 0x18, 0x10, 0xE5, 0x11, 0x80,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x19, 0x80, 0x2F, 0x80, 0x4F, 0xC0, 0x7A, 0x00, 0xAD, 0xC0, 0xEB, 0x00
-	},	
- 
-	/* GM_1_0 */
-	{
-		 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00,
-		 0x10, 0x20, 0x40, 0x60, 0x80, 0xA0, 0xEB,
-		 0x10, 0x00, 0x20, 0x00, 0x40, 0x00, 0x60, 0x00, 0x80, 0x00, 0xA0, 0x00, 0xEB, 0x00
-	},	
- 
-	/* GM_1_1 */
-	{
-		 0x14, 0xEC, 0x11, 0xC2, 0x10, 0x78, 0x0F, 0xB6, 0x0F, 0x2F, 0x0E, 0xB6,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x21, 0x00, 0x3C, 0xC0, 0x5F, 0xC0, 0x89, 0x00, 0xB7, 0x80, 0xEB, 0x00
-	},	
- 
-	/* GM_1_2 */
-	{
-		 0x19, 0xD8, 0x13, 0x33, 0x10, 0xD2, 0x0F, 0x6D, 0x0E, 0x5E, 0x0D, 0xA4,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x25, 0x00, 0x43, 0x00, 0x66, 0xC0, 0x8F, 0x40, 0xBB, 0x40, 0xEB, 0x00
-	},	
- 
-	/* GM_1_3 */
-	{
-		 0x1E, 0xC4, 0x14, 0x7A, 0x11, 0x0F, 0xF, 0x0C, 0x0D, 0xA1, 0x0C, 0xB6,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x29, 0x00, 0x49, 0x00, 0x6D, 0x40, 0x94, 0xC0, 0xBE, 0x80, 0xEB, 0x00
-	},	
- 
-	/* GM_1_4 */
-	{
-		 0x24, 0x00, 0x15, 0x70, 0x11, 0x0F, 0x0E, 0xAA, 0x0D, 0x0F, 0x0B, 0xDB,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x2D, 0x40, 0x4E, 0xC0, 0x73, 0x00, 0x99, 0x80, 0xC1, 0x80, 0xEB, 0x00
- 	},	
- 
-	/* GM_1_5 */
-	{
-		 0x29, 0x3B, 0x16, 0x3D, 0x11, 0x0F, 0x0E, 0x30, 0x0C, 0x7D, 0x0B, 0x24,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x31, 0x80, 0x54, 0x40, 0x78, 0x80, 0x9D, 0xC0, 0xC4, 0x00, 0xEB, 0x00
-	},	
- 
-	/* GM_1_6 */
-	{
-		 0x2E, 0x27, 0x17, 0x0A, 0x10, 0xD2, 0x0D, 0xE7, 0x0B, 0xEB, 0x0A, 0x80,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x35, 0x80, 0x59, 0x80, 0x7D, 0x40, 0xA1, 0xC0, 0xC6, 0x40, 0xEB, 0x00
-	},	
- 
-	/* GM_1_7 */
-	{
-		 0x33, 0x62, 0x17, 0x5C, 0x10, 0xD2, 0x0D, 0x6D, 0x0B, 0x6D, 0x09, 0xED,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x39, 0xC0, 0x5E, 0x40, 0x82, 0x00, 0xA5, 0x40, 0xC8, 0x40, 0xEB, 0x00
-	},	
- 
-	/* GM_1_8 */
-	{
-		 0x38, 0x4E, 0x17, 0xAE, 0x10, 0xB4, 0x0D, 0x0C, 0x0A, 0xF0, 0x09, 0x6D,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x3D, 0xC0, 0x62, 0xC0, 0x86, 0x40, 0xA8, 0x80, 0xCA, 0x00, 0xEB, 0x00
-	},	
- 
-	/* GM_1_9 */
-	{
-		 0x3D, 0x3B, 0x18, 0x00, 0x10, 0x5A, 0x0C, 0xC3, 0x0A, 0x72, 0x09, 0x00,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x41, 0xC0, 0x67, 0x40, 0x8A, 0x00, 0xAB, 0x80, 0xCB, 0x80, 0xEB, 0x00
-	},	
- 
-	/* GM_2_0 */
-	{
-		 0x41, 0xD8, 0x18, 0x28, 0x10, 0x3C, 0x0C, 0x49, 0x0A, 0x1F, 0x08, 0x92,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x45, 0x80, 0x6B, 0x40, 0x8D, 0xC0, 0xAE, 0x00, 0xCD, 0x00, 0xEB, 0x00
-	},	
- 
-	/* GM_2_1 */
-	{
-		 0x46, 0x76, 0x18, 0x51, 0x0F, 0xE1, 0x0C, 0x00, 0x09, 0xB6, 0x08, 0x36,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x49, 0x40, 0x6F, 0x40, 0x91, 0x00, 0xB0, 0x80, 0xCE, 0x40, 0xEB, 0x00
-	},	
- 
-	/* GM_2_2 */
-	{
-		 0x4A, 0xC4, 0x18, 0x7A, 0x0F, 0xA5, 0x0B, 0x9E, 0x09, 0x63, 0x07, 0xDB,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x4C, 0xC0, 0x73, 0x00, 0x94, 0x40, 0xB2, 0xC0, 0xCF, 0x80, 0xEB, 0x00
-	},	
- 
-	/* GM_2_3 */
-	{
-		 0x4F, 0x13, 0x18, 0x51, 0x0F, 0x69, 0x0B, 0x6D, 0x09, 0x0F, 0x07, 0x80,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x50, 0x40, 0x76, 0x40, 0x97, 0x00, 0xB5, 0x00, 0xD0, 0xC0, 0xEB, 0x00
-	},	
- 
-	/* GM_2_4 */
-	{
-		 0x53, 0x13, 0x18, 0x7A, 0x0F, 0x0F, 0x0B, 0x24, 0x08, 0xBC, 0x07, 0x36,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x53, 0x80, 0x79, 0xC0, 0x99, 0xC0, 0xB7, 0x00, 0xD1, 0xC0, 0xEB, 0x00
-	},	
- 
-	/* GM_2_5 */
-	{
-		 0x57, 0x13, 0x18, 0x51, 0x0E, 0xF0, 0x0A, 0xC3, 0x08, 0x7D, 0x06, 0xED,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x56, 0xC0, 0x7C, 0xC0, 0x9C, 0x80, 0xB8, 0xC0, 0xD2, 0xC0, 0xEB, 0x00
-	},	
- 
-	/* GM_2_6 */
-	{
-		 0x5B, 0x13, 0x18, 0x28, 0x0E, 0x96, 0x0A, 0x92, 0x08, 0x29, 0x06, 0xB6,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x5A, 0x00, 0x7F, 0xC0, 0x9E, 0xC0, 0xBA, 0x80, 0xD3, 0x80, 0xEB, 0x00
-	},	
- 
-	/* GM_2_7 */
-	{
-		 0x5E, 0xC4, 0x18, 0x00, 0x0E, 0x78, 0x0A, 0x30, 0x08, 0x00, 0x06, 0x6D,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x5D, 0x00, 0x82, 0x80, 0xA1, 0x40, 0xBC, 0x00, 0xD4, 0x80, 0xEB, 0x00
-	},	
- 
-	/* GM_2_8 */
-	{
-		 0x62, 0x76, 0x17, 0xD7, 0x0E, 0x1E, 0x0A, 0x00, 0x07, 0xC1, 0x06, 0x36,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x60, 0x00, 0x85, 0x40, 0xA3, 0x40, 0xBD, 0x80, 0xD5, 0x40, 0xEB, 0x00
-	},	
- 
-	/* GM_2_9 */
-	{
-		 0x65, 0xD8, 0x17, 0xAE, 0x0D, 0xE1, 0x09, 0xCF, 0x07, 0x82, 0x06, 0x00,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x62, 0xC0, 0x87, 0xC0, 0xA5, 0x40, 0xBF, 0x00, 0xD6, 0x00, 0xEB, 0x00
-	},	
- 
-	/* GM_3_0 */
-	{
-		 0x69, 0x3B, 0x17, 0x85, 0x0D, 0xA5, 0x09, 0x86, 0x07, 0x43, 0x05, 0xDB,
-		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
-		 0x10, 0x00, 0x65, 0x80, 0x8A, 0x40, 0xA7, 0x40, 0xC0, 0x40, 0xD6, 0x80, 0xEB, 0x00
-	}
-};
-
-void __VISetTiming(u8 timing)
-{
-  __VIWriteI2CRegister8(0x00,timing);
-}
-
-void __VISetYUVSEL(u8 dtvstatus)
-{
-  u8 vdacFlagRegion = 0;
-  u32 currTvMode = _SHIFTR(_viReg[1],8,2);
-  if(currTvMode==VI_PAL || currTvMode==VI_EURGB60)
-    vdacFlagRegion = 2;
-	else if(currTvMode==VI_MPAL)
-    vdacFlagRegion = 1;
-
-	__VIWriteI2CRegister8(0x01, _SHIFTL(dtvstatus,5,3)|(vdacFlagRegion&0x1f)); 
-}
-
-void __VISetVBICtrl(u16 data)
-{
-	__VIWriteI2CRegister16(0x02, data);
-}
-
-void __VISetTrapFilter(u8 disable)
-{
-	if (disable)
-    __VIWriteI2CRegister8(0x03, 0);
-	else
-    __VIWriteI2CRegister8(0x03, 1);
-}
-
-void __VISet3in1Output(u8 enable)
-{
-  __VIWriteI2CRegister8(0x04,enable);
-}
-
-void __VISetCGMS(u16 value)
-{
-	__VIWriteI2CRegister16(0x05, value);
-}
-
-void __VISetWSS(u16 value)
-{
-	__VIWriteI2CRegister16(0x08, value);
-}
-
-void __VISetRGBOverDrive(u8 value)
-{
-  u32 currTvMode = _SHIFTR(_viReg[1],8,2);
-  if (currTvMode == VI_DEBUG)
-    __VIWriteI2CRegister8(0x0A,(value<<1)|1);
-  else
-    __VIWriteI2CRegister8(0x0A,0);
-}
-
-void __VISetOverSampling(void)
-{
-  __VIWriteI2CRegister8(0x65,1);
-}
-
-void __VISetCCSEL(void)
-{
-  __VIWriteI2CRegister8(0x6a,1);
-}
-
-void __VISetFilterEURGB60(u8 enable)
-{
-	__VIWriteI2CRegister8(0x6e, enable);
-}
-
-void __VISetVolume(u16 value)
-{
-  __VIWriteI2CRegister16(0x71,value);
-}
-
-void __VISetClosedCaption(u32 value)
-{
-	__VIWriteI2CRegister32(0x7a, value);
-}
-
-void __VISetGamma(VIGamma gamma)
-{
-  u8 *data = (u8 *)&gamma_coeffs[gamma][0];
-  __VIWriteI2CRegisterBuf(0x10, 0x21, data);
-}
-
-/* User Configurable */
-
-void VIDEO_SetGamma(VIGamma gamma)
-{
-  __VISetGamma(gamma);
-}
-
-void VIDEO_SetTrapFilter(bool enable)
-{
-  if (enable)
-    __VISetTrapFilter(0);
-  else
-    __VISetTrapFilter(1);
-}
-
-#endif
Index: source/gx/vi_encoder.h
===================================================================
--- source/gx/vi_encoder.h	(revision 440)
+++ source/gx/vi_encoder.h	(revision 441)
@@ -1,64 +0,0 @@
-/****************************************************************************
- *  vi_encoder.c
- *
- *  Wii Audio/Video Encoder support
- *
- *  Copyright (C) 2009 Hector Martin (marcan)
- *  Additional code by Eke-Eke
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- ***************************************************************************/
-#if defined(HW_RVL)
-
-typedef enum
-{
-    VI_GM_0_1=1,
-    VI_GM_0_2,
-    VI_GM_0_3,
-    VI_GM_0_4,
-    VI_GM_0_5,
-    VI_GM_0_6,
-    VI_GM_0_7,
-    VI_GM_0_8,
-    VI_GM_0_9,
-    VI_GM_1_0,
-    VI_GM_1_1,
-    VI_GM_1_2,
-    VI_GM_1_3,
-    VI_GM_1_4,
-    VI_GM_1_5,
-    VI_GM_1_6,
-    VI_GM_1_7,
-    VI_GM_1_8,
-    VI_GM_1_9,
-    VI_GM_2_0,
-    VI_GM_2_1,
-    VI_GM_2_2,
-    VI_GM_2_3,
-    VI_GM_2_4,
-    VI_GM_2_5,
-    VI_GM_2_6,
-    VI_GM_2_7,
-    VI_GM_2_8,
-    VI_GM_2_9,
-    VI_GM_3_0
-} VIGamma;
-
-extern void VIDEO_SetGamma(VIGamma gamma);
-extern void VIDEO_SetTrapFilter(bool enable);
-
-
-#endif
Index: source/gx/gui/oggplayer.h
===================================================================
--- source/gx/gui/oggplayer.h	(revision 440)
+++ source/gx/gui/oggplayer.h	(revision 441)
@@ -1,176 +0,0 @@
-/*
- Copyright (c) 2008 Francisco Muñoz 'Hermes' <www.elotrolado.net>
- All rights reserved.
-
- Redistribution and use in source and binary forms, with or without modification, are
- permitted provided that the following conditions are met:
-
- - Redistributions of source code must retain the above copyright notice, this list of
- conditions and the following disclaimer.
- - Redistributions in binary form must reproduce the above copyright notice, this list
- of conditions and the following disclaimer in the documentation and/or other
- materials provided with the distribution.
- - The names of the contributors may not be used to endorse or promote products derived
- from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
- EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
- THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#ifndef NO_SOUND
-
-#ifndef __OGGPLAYER_H__
-#define __OGGPLAYER_H__
-
-#include <asndlib.h>
-#include "tremor/ivorbiscodec.h"
-#include "tremor/ivorbisfile.h"
-
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-
-#define OGG_ONE_TIME         0
-#define OGG_INFINITE_TIME    1
-
-#define OGG_STATUS_RUNNING   1
-#define OGG_STATUS_ERR      -1
-#define OGG_STATUS_PAUSED    2
-#define OGG_STATUS_EOF     255
-
-/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
-/* Player OGG functions                                                                                                                                 */
-/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
-
-/* int PlayOgg(int fd, int time_pos, int mode);
-
- Play an Ogg file. This file can be loaded from memory (mem_open(void *ogg, int size_ogg)) or from device with open("device:file.ogg",O_RDONLY,0);
-
- NOTE: The file is closed by the player when you call PlayOgg(), StopOgg() or if it fail.
-
- -- Params ---
-
- buf: pointer to sound data
-
- buflen: buffer size in bytes
-
- time_pos: initial time position in the file (in milliseconds). For example, use 30000 to advance 30 seconds
-
- mode: Use OGG_ONE_TIME or OGG_INFINITE_TIME. When you use OGG_ONE_TIME the sound stops and StatusOgg() return OGG_STATUS_EOF
-
- return: 0- Ok, -1 Error
-
- */
-
-int PlayOgg(char * buf, int buflen, int time_pos, int mode);
-
-/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
-
-/* void StopOgg();
-
- Stop an Ogg file.
-
- NOTE: The file is closed and the player thread is released
-
- -- Params ---
-
-
- */
-
-void StopOgg();
-
-/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
-
-/* void PauseOgg(int pause);
-
- Pause an Ogg file.
-
- -- Params ---
-
- pause: 0 -> continue, 1-> pause
-
- */
-
-void PauseOgg(int pause);
-
-/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
-
-/* int StatusOgg();
-
- Return the Ogg status
-
- -- Params ---
-
-
- return: OGG_STATUS_RUNNING
- OGG_STATUS_ERR    -> not initialized?
- OGG_STATUS_PAUSED
- OGG_STATUS_EOF    -> player stopped by End Of File
-
- */
-
-int StatusOgg();
-
-/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
-
-/* void SetVolumeOgg(int volume);
-
- Set the Ogg playing volume.
- NOTE: it change the volume of voice 0 (used for the Ogg player)
-
- -- Params ---
-
- volume: 0 to 255 (max)
-
- */
-
-void SetVolumeOgg(int volume);
-
-/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
-
-/* s32 GetTimeOgg();
-
- Return the Ogg time from the starts of the file
-
- -- Params ---
-
- return:  0 -> Ok or error condition  (you must ignore this value)
- >0 -> time in milliseconds from the starts
-
- */
-
-s32 GetTimeOgg();
-
-/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
-
-/* void SetTimeOgg(s32 time_pos);
-
- Set the time position
-
- NOTE: The file is closed by the player when you call PlayOgg(), StopOgg() or if it fail.
-
- -- Params ---
-
- time_pos: time position in the file (in milliseconds). For example, use 30000 to advance 30 seconds
-
- */
-
-void SetTimeOgg(s32 time_pos);
-
-/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif
-
-#endif
Index: source/gx/gui/oggplayer.c
===================================================================
--- source/gx/gui/oggplayer.c	(revision 440)
+++ source/gx/gui/oggplayer.c	(revision 441)
@@ -1,536 +0,0 @@
-/*
- Copyright (c) 2008 Francisco Muñoz 'Hermes' <www.elotrolado.net>
- All rights reserved.
-
- Proper (standard) vorbis usage by Tantric, 2009
- Threading modifications/corrections by Tantric, 2009
-
- Redistribution and use in source and binary forms, with or without modification, are
- permitted provided that the following conditions are met:
-
- - Redistributions of source code must retain the above copyright notice, this list of
- conditions and the following disclaimer.
- - Redistributions in binary form must reproduce the above copyright notice, this list
- of conditions and the following disclaimer in the documentation and/or other
- materials provided with the distribution.
- - The names of the contributors may not be used to endorse or promote products derived
- from this software without specific prior written permission.
-
- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
- EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
- THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
- SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
- PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
- INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
- THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-#include "oggplayer.h"
-#include <gccore.h>
-#include <unistd.h>
-#include <string.h>
-
-/* functions to read the Ogg file from memory */
-
-static struct
-{
-  char *mem;
-  int size;
-  int pos;
-} file[4];
-
-static int f_read(void * punt, int bytes, int blocks, int *f)
-{
-  int b;
-  int c;
-  int d;
-
-  if (bytes * blocks <= 0)
-    return 0;
-
-  blocks = bytes * blocks;
-  c = 0;
-
-  while (blocks > 0)
-  {
-    b = blocks;
-    if (b > 4096)
-      b = 4096;
-
-    if (*f >= 0x666 && *f <= 0x669)
-    {
-      d = (*f) - 0x666;
-      if (file[d].size == 0)
-        return -1;
-      if ((file[d].pos + b) > file[d].size)
-        b = file[d].size - file[d].pos;
-      if (b > 0)
-      {
-        memcpy(punt, file[d].mem + file[d].pos, b);
-        file[d].pos += b;
-      }
-    }
-    else
-      b = read(*f, ((char *) punt) + c, b);
-
-    if (b <= 0)
-    {
-      return c / bytes;
-    }
-    c += b;
-    blocks -= b;
-  }
-  return c / bytes;
-}
-
-static int f_seek(int *f, ogg_int64_t offset, int mode)
-{
-  if(f==NULL) return(-1);
-
-  int k, d;
-  mode &= 3;
-  if (*f >= 0x666 && *f <= 0x669)
-  {
-    d = (*f) - 0x666;
-    k = 0;
-
-    if (file[d].size == 0)
-      return -1;
-
-    if (mode == 0)
-    {
-      if ((offset) >= file[d].size)
-      {
-        file[d].pos = file[d].size;
-        k = -1;
-      }
-      else if ((offset) < 0)
-      {
-        file[d].pos = 0;
-        k = -1;
-      }
-      else
-        file[d].pos = offset;
-    }
-    if (mode == 1)
-    {
-      if ((file[d].pos + offset) >= file[d].size)
-      {
-        file[d].pos = file[d].size;
-        k = -1;
-      }
-      else if ((file[d].pos + offset) < 0)
-      {
-        file[d].pos = 0;
-        k = -1;
-      }
-      else
-        file[d].pos += offset;
-    }
-    if (mode == 2)
-    {
-
-      if ((file[d].size + offset) >= file[d].size)
-      {
-        file[d].pos = file[d].size;
-        k = -1;
-      }
-      else if ((file[d].size + offset) < 0)
-      {
-        file[d].pos = 0;
-        k = -1;
-      }
-      else
-        file[d].pos = file[d].size + offset;
-    }
-
-  }
-  else
-    k = lseek(*f, (int) offset, mode);
-
-  if (k < 0)
-    k = -1;
-  else
-    k = 0;
-  return k;
-}
-
-static int f_close(int *f)
-{
-  int d;
-  if (*f >= 0x666 && *f <= 0x669)
-  {
-    d = (*f) - 0x666;
-    file[d].size = 0;
-    file[d].pos = 0;
-    if (file[d].mem)
-    {
-      file[d].mem = (void *) 0;
-    }
-    return 0;
-  }
-  else
-    return close(*f);
-  return 0;
-}
-
-static long f_tell(int *f)
-{
-  int k, d;
-
-  if (*f >= 0x666 && *f <= 0x669)
-  {
-    d = (*f) - 0x666;
-    k = file[d].pos;
-  }
-  else
-    k = lseek(*f, 0, 1);
-
-  return (long) k;
-}
-
-static int mem_open(char * ogg, int size)
-{
-  static int one = 1;
-  int n;
-  if (one)
-  {
-    one = 0;
-    for (n = 0; n < 4; n++)
-      file[n].size = 0;
-  }
-
-  for (n = 0; n < 4; n++)
-  {
-    if (file[n].size == 0)
-    {
-      file[n].mem = ogg;
-      file[n].size = size;
-      file[n].pos = 0;
-      return (0x666 + n);
-    }
-  }
-  return -1;
-}
-
-static int mem_close(int fd)
-{
-  if (fd >= 0x666 && fd <= 0x669) // it is a memory file descriptor?
-  {
-    fd -= 0x666;
-    file[fd].size = 0;
-    return 0;
-  }
-  else
-    return f_close(&fd);
-}
-
-static ov_callbacks callbacks = {
-  (size_t (*)(void *, size_t, size_t, void *))  f_read,
-  (int (*)(void *, ogg_int64_t, int))           f_seek,
-  (int (*)(void *))                             f_close,
-  (long (*)(void *))                            f_tell
-};
-
-/* OGG control */
-
-#define READ_SAMPLES 4096 /* samples that it must read before to send */
-#define MAX_PCMOUT 4096 /* minimum size to read ogg samples */
-typedef struct
-{
-  OggVorbis_File vf;
-  vorbis_info *vi;
-  int current_section;
-
-  /* OGG file operation */
-  int fd;
-  int mode;
-  int eof;
-  int flag;
-  int volume;
-  int seek_time;
-
-  /* OGG buffer control */
-  short pcmout[2][READ_SAMPLES + MAX_PCMOUT * 2]; /* take 4k out of the data segment, not the stack */
-  int pcmout_pos;
-  int pcm_indx;
-
-} private_data_ogg;
-
-static private_data_ogg private_ogg;
-
-/* OGG thread control */
-
-#define STACKSIZE    8192
-
-static u8 oggplayer_stack[STACKSIZE];
-static lwpq_t oggplayer_queue = LWP_TQUEUE_NULL;
-static lwp_t h_oggplayer = LWP_THREAD_NULL;
-static int ogg_thread_running = 0;
-
-static void ogg_add_callback(int voice)
-{
-  if (!ogg_thread_running)
-  {
-    ASND_StopVoice(0);
-    return;
-  }
-
-  if (private_ogg.flag & 128)
-    return; /* Ogg is paused */
-
-  if (private_ogg.pcm_indx >= READ_SAMPLES)
-  {
-    if (ASND_AddVoice(0,
-        (void *) private_ogg.pcmout[private_ogg.pcmout_pos],
-        private_ogg.pcm_indx << 1) == 0)
-    {
-      private_ogg.pcmout_pos ^= 1;
-      private_ogg.pcm_indx = 0;
-      private_ogg.flag = 0;
-      LWP_ThreadSignal(oggplayer_queue);
-    }
-  }
-  else
-  {
-    if (private_ogg.flag & 64)
-    {
-      private_ogg.flag &= ~64;
-      LWP_ThreadSignal(oggplayer_queue);
-    }
-  }
-}
-
-static void * ogg_player_thread(private_data_ogg * priv)
-{
-  int first_time = 1;
-  long ret;
-
-  /* init */
-  LWP_InitQueue(&oggplayer_queue);
-
-  priv[0].vi = ov_info(&priv[0].vf, -1);
-
-  ASND_Pause(0);
-
-  priv[0].pcm_indx = 0;
-  priv[0].pcmout_pos = 0;
-  priv[0].eof = 0;
-  priv[0].flag = 0;
-  priv[0].current_section = 0;
-
-  ogg_thread_running = 1;
-
-  while (!priv[0].eof && ogg_thread_running)
-  {
-    if (priv[0].flag)
-      LWP_ThreadSleep(oggplayer_queue); /* wait only when i have samples to send */
-
-    if (priv[0].flag == 0) /* wait to all samples are sended */
-    {
-      if (ASND_TestPointer(0, priv[0].pcmout[priv[0].pcmout_pos])
-          && ASND_StatusVoice(0) != SND_UNUSED)
-      {
-        priv[0].flag |= 64;
-        continue;
-      }
-      if (priv[0].pcm_indx < READ_SAMPLES)
-      {
-        priv[0].flag = 3;
-
-        if (priv[0].seek_time >= 0)
-        {
-          ov_time_seek(&priv[0].vf, priv[0].seek_time);
-          priv[0].seek_time = -1;
-        }
-
-        ret
-            = ov_read(
-                &priv[0].vf,
-                (void *) &priv[0].pcmout[priv[0].pcmout_pos][priv[0].pcm_indx],
-                MAX_PCMOUT,/*0,2,1,*/&priv[0].current_section);
-        priv[0].flag &= 192;
-        if (ret == 0)
-        {
-          /* EOF */
-          if (priv[0].mode & 1)
-            ov_time_seek(&priv[0].vf, 0); /* repeat */
-          else
-            priv[0].eof = 1; /* stops */
-        }
-        else if (ret < 0)
-        {
-          /* error in the stream.  Not a problem, just reporting it in
-           case we (the app) cares.  In this case, we don't. */
-          if (ret != OV_HOLE)
-          {
-            if (priv[0].mode & 1)
-              ov_time_seek(&priv[0].vf, 0); /* repeat */
-            else
-              priv[0].eof = 1; /* stops */
-          }
-        }
-        else
-        {
-          /* we don't bother dealing with sample rate changes, etc, but
-           you'll have to */
-          priv[0].pcm_indx += ret >> 1; /* get 16 bits samples */
-        }
-      }
-      else
-        priv[0].flag = 1;
-    }
-
-    if (priv[0].flag == 1)
-    {
-      if (ASND_StatusVoice(0) == SND_UNUSED || first_time)
-      {
-        first_time = 0;
-        if (priv[0].vi->channels == 2)
-        {
-          ASND_SetVoice(0, VOICE_STEREO_16BIT, priv[0].vi->rate, 0,
-              (void *) priv[0].pcmout[priv[0].pcmout_pos],
-              priv[0].pcm_indx << 1, priv[0].volume,
-              priv[0].volume, ogg_add_callback);
-          priv[0].pcmout_pos ^= 1;
-          priv[0].pcm_indx = 0;
-          priv[0].flag = 0;
-        }
-        else
-        {
-          ASND_SetVoice(0, VOICE_MONO_16BIT, priv[0].vi->rate, 0,
-              (void *) priv[0].pcmout[priv[0].pcmout_pos],
-              priv[0].pcm_indx << 1, priv[0].volume,
-              priv[0].volume, ogg_add_callback);
-          priv[0].pcmout_pos ^= 1;
-          priv[0].pcm_indx = 0;
-          priv[0].flag = 0;
-        }
-      }
-    }
-    usleep(10);
-  }
-  ov_clear(&priv[0].vf);
-  priv[0].fd = -1;
-  priv[0].pcm_indx = 0;
-
-  return 0;
-}
-
-void StopOgg()
-{
-  ASND_StopVoice(0);
-  ogg_thread_running = 0;
-
-  if(h_oggplayer != LWP_THREAD_NULL)
-  {
-    if(oggplayer_queue != LWP_TQUEUE_NULL)
-      LWP_ThreadSignal(oggplayer_queue);
-    LWP_JoinThread(h_oggplayer, NULL);
-    h_oggplayer = LWP_THREAD_NULL;
-  }
-  if(oggplayer_queue != LWP_TQUEUE_NULL)
-  {
-    LWP_CloseQueue(oggplayer_queue);
-    oggplayer_queue = LWP_TQUEUE_NULL;
-  }
-}
-
-int PlayOgg(char * buf, int buflen, int time_pos, int mode)
-{
-  StopOgg();
-
-  private_ogg.fd = mem_open(buf, buflen);
-  
-  if (private_ogg.fd < 0)
-  {
-    private_ogg.fd = -1;
-    return -1;
-  }
-
-  private_ogg.mode = mode;
-  private_ogg.eof = 0;
-  private_ogg.volume = 127;
-  private_ogg.flag = 0;
-  private_ogg.seek_time = -1;
-
-  if (time_pos > 0)
-    private_ogg.seek_time = time_pos;
-
-  if (ov_open_callbacks((void *) &private_ogg.fd, &private_ogg.vf, NULL, 0, callbacks) < 0)
-  {
-    mem_close(private_ogg.fd); /* mem_close() can too close files from devices */
-    private_ogg.fd = -1;
-    ogg_thread_running = 0;
-    return -1;
-  }
-
-  if (LWP_CreateThread(&h_oggplayer, (void *) ogg_player_thread,
-      &private_ogg, oggplayer_stack, STACKSIZE, 80) == -1)
-  {
-    ogg_thread_running = 0;
-    ov_clear(&private_ogg.vf);
-    private_ogg.fd = -1;
-    return -1;
-  }
-  return 0;
-}
-
-void PauseOgg(int pause)
-{
-  if (pause)
-  {
-    private_ogg.flag |= 128;
-  }
-  else
-  {
-    if (private_ogg.flag & 128)
-    {
-      private_ogg.flag |= 64;
-      private_ogg.flag &= ~128;
-      if (ogg_thread_running > 0)
-      {
-        LWP_ThreadSignal(oggplayer_queue);
-      }
-    }
-  }
-}
-
-int StatusOgg()
-{
-  if (ogg_thread_running == 0)
-    return -1; /* Error */
-  else if (private_ogg.eof)
-    return 255; /* EOF */
-  else if (private_ogg.flag & 128)
-    return 2; /* paused */
-  else
-    return 1; /* running */
-}
-
-void SetVolumeOgg(int volume)
-{
-  private_ogg.volume = volume;
-  ASND_ChangeVolumeVoice(0, volume, volume);
-}
-
-s32 GetTimeOgg()
-{
-  int ret;
-  if (ogg_thread_running == 0 || private_ogg.fd < 0)
-    return 0;
-  ret = ((s32) ov_time_tell(&private_ogg.vf));
-  if (ret < 0)
-    ret = 0;
-
-  return ret;
-}
-
-void SetTimeOgg(s32 time_pos)
-{
-  if (time_pos >= 0)
-    private_ogg.seek_time = time_pos;
-}
-
Index: source/gx/gui/menu.c
===================================================================
--- source/gx/gui/menu.c	(revision 440)
+++ source/gx/gui/menu.c	(revision 441)
@@ -127,7 +127,7 @@
   {NULL,Banner_top_png,IMAGE_VISIBLE,0,0,640,108,255},
   {NULL,Banner_bottom_png,IMAGE_VISIBLE,0,380,640,100,255},
   {NULL,Main_logo_png,IMAGE_VISIBLE,466,40,152,44,255},
-  {NULL,Frame_s1_png,IMAGE_VISIBLE,8,70,372,336,128}
+  {NULL,Frame_s1_png,IMAGE_VISIBLE,8,70,372,336,64}
 };
 
 /*****************************************************************************/
Index: source/gx/utils/oggplayer.h
===================================================================
--- source/gx/utils/oggplayer.h	(revision 0)
+++ source/gx/utils/oggplayer.h	(revision 441)
@@ -0,0 +1,176 @@
+/*
+ Copyright (c) 2008 Francisco Muñoz 'Hermes' <www.elotrolado.net>
+ All rights reserved.
+
+ Redistribution and use in source and binary forms, with or without modification, are
+ permitted provided that the following conditions are met:
+
+ - Redistributions of source code must retain the above copyright notice, this list of
+ conditions and the following disclaimer.
+ - Redistributions in binary form must reproduce the above copyright notice, this list
+ of conditions and the following disclaimer in the documentation and/or other
+ materials provided with the distribution.
+ - The names of the contributors may not be used to endorse or promote products derived
+ from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
+ EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
+ THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef NO_SOUND
+
+#ifndef __OGGPLAYER_H__
+#define __OGGPLAYER_H__
+
+#include <asndlib.h>
+#include "tremor/ivorbiscodec.h"
+#include "tremor/ivorbisfile.h"
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+#define OGG_ONE_TIME         0
+#define OGG_INFINITE_TIME    1
+
+#define OGG_STATUS_RUNNING   1
+#define OGG_STATUS_ERR      -1
+#define OGG_STATUS_PAUSED    2
+#define OGG_STATUS_EOF     255
+
+/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
+/* Player OGG functions                                                                                                                                 */
+/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
+
+/* int PlayOgg(int fd, int time_pos, int mode);
+
+ Play an Ogg file. This file can be loaded from memory (mem_open(void *ogg, int size_ogg)) or from device with open("device:file.ogg",O_RDONLY,0);
+
+ NOTE: The file is closed by the player when you call PlayOgg(), StopOgg() or if it fail.
+
+ -- Params ---
+
+ buf: pointer to sound data
+
+ buflen: buffer size in bytes
+
+ time_pos: initial time position in the file (in milliseconds). For example, use 30000 to advance 30 seconds
+
+ mode: Use OGG_ONE_TIME or OGG_INFINITE_TIME. When you use OGG_ONE_TIME the sound stops and StatusOgg() return OGG_STATUS_EOF
+
+ return: 0- Ok, -1 Error
+
+ */
+
+int PlayOgg(char * buf, int buflen, int time_pos, int mode);
+
+/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
+
+/* void StopOgg();
+
+ Stop an Ogg file.
+
+ NOTE: The file is closed and the player thread is released
+
+ -- Params ---
+
+
+ */
+
+void StopOgg();
+
+/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
+
+/* void PauseOgg(int pause);
+
+ Pause an Ogg file.
+
+ -- Params ---
+
+ pause: 0 -> continue, 1-> pause
+
+ */
+
+void PauseOgg(int pause);
+
+/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
+
+/* int StatusOgg();
+
+ Return the Ogg status
+
+ -- Params ---
+
+
+ return: OGG_STATUS_RUNNING
+ OGG_STATUS_ERR    -> not initialized?
+ OGG_STATUS_PAUSED
+ OGG_STATUS_EOF    -> player stopped by End Of File
+
+ */
+
+int StatusOgg();
+
+/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
+
+/* void SetVolumeOgg(int volume);
+
+ Set the Ogg playing volume.
+ NOTE: it change the volume of voice 0 (used for the Ogg player)
+
+ -- Params ---
+
+ volume: 0 to 255 (max)
+
+ */
+
+void SetVolumeOgg(int volume);
+
+/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
+
+/* s32 GetTimeOgg();
+
+ Return the Ogg time from the starts of the file
+
+ -- Params ---
+
+ return:  0 -> Ok or error condition  (you must ignore this value)
+ >0 -> time in milliseconds from the starts
+
+ */
+
+s32 GetTimeOgg();
+
+/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
+
+/* void SetTimeOgg(s32 time_pos);
+
+ Set the time position
+
+ NOTE: The file is closed by the player when you call PlayOgg(), StopOgg() or if it fail.
+
+ -- Params ---
+
+ time_pos: time position in the file (in milliseconds). For example, use 30000 to advance 30 seconds
+
+ */
+
+void SetTimeOgg(s32 time_pos);
+
+/*------------------------------------------------------------------------------------------------------------------------------------------------------*/
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+#endif
Index: source/gx/utils/ehcmodule_elf.h
===================================================================
--- source/gx/utils/ehcmodule_elf.h	(revision 0)
+++ source/gx/utils/ehcmodule_elf.h	(revision 441)
@@ -0,0 +1,3 @@
+extern const u8 ehcmodule_elf_end[];
+extern const u8 ehcmodule_elf[];
+extern const u32 ehcmodule_elf_size;
Index: source/gx/utils/usb2storage.c
===================================================================
--- source/gx/utils/usb2storage.c	(revision 0)
+++ source/gx/utils/usb2storage.c	(revision 441)
@@ -0,0 +1,455 @@
+/*-------------------------------------------------------------
+
+usb2storage.c -- USB mass storage support, inside starlet
+Copyright (C) 2008 Kwiirk
+Improved for homebrew by rodries
+
+If this driver is linked before libogc, this will replace the original 
+usbstorage driver by svpe from libogc
+
+CIOS_usb2 must be loaded!
+
+This software is provided 'as-is', without any express or implied
+warranty.	In no event will the authors be held liable for any
+damages arising from the use of this software.
+
+Permission is granted to anyone to use this software for any
+purpose, including commercial applications, and to alter it and
+redistribute it freely, subject to the following restrictions:
+
+1.	The origin of this software must not be misrepresented; you
+must not claim that you wrote the original software. If you use
+this software in a product, an acknowledgment in the product
+documentation would be appreciated but is not required.
+
+2.	Altered source versions must be plainly marked as such, and
+must not be misrepresented as being the original software.
+
+3.	This notice may not be removed or altered from any source
+distribution.
+
+ -------------------------------------------------------------*/
+
+#ifdef HW_RVL
+
+#include <gccore.h>
+
+#include <ogc/lwp_heap.h>
+#include <malloc.h>
+#include <ogc/disc_io.h>
+#include <ogc/usbstorage.h>
+#include <ogc/mutex.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h> 
+#include <ogc/machine/processor.h>
+#include <ogc/ipc.h>
+
+//#define DEBUG_USB2
+
+#ifdef DEBUG_USB2
+#define debug_printf(fmt, args...) \
+	fprintf(stderr, "%s:%d:" fmt, __FUNCTION__, __LINE__, ##args)
+#else
+#define debug_printf(fmt, args...)
+#endif // DEBUG_USB2
+
+#define UMS_BASE (('U'<<24)|('M'<<16)|('S'<<8))
+#define USB_IOCTL_UMS_INIT						(UMS_BASE+0x1)
+#define USB_IOCTL_UMS_GET_CAPACITY				(UMS_BASE+0x2)
+#define USB_IOCTL_UMS_READ_SECTORS				(UMS_BASE+0x3)
+#define USB_IOCTL_UMS_WRITE_SECTORS		(UMS_BASE+0x4)
+#define USB_IOCTL_UMS_READ_STRESS		(UMS_BASE+0x5)
+#define USB_IOCTL_UMS_SET_VERBOSE		(UMS_BASE+0x6)
+#define USB_IOCTL_UMS_IS_INSERTED		(UMS_BASE+0x7)
+
+#define USB_IOCTL_UMS_UMOUNT			(UMS_BASE+0x10)
+#define USB_IOCTL_UMS_START			(UMS_BASE+0x11)
+#define USB_IOCTL_UMS_STOP			(UMS_BASE+0x12)
+#define USB_IOCTL_UMS_EXIT			(UMS_BASE+0x16)
+
+#define UMS_HEAPSIZE					2*1024
+#define UMS_MAXPATH 16
+
+static s32 hId = -1;
+static s32 fd = -1;
+static u32 sector_size;
+static s32 usb2 = -1;
+static mutex_t usb2_mutex = LWP_MUTEX_NULL;
+static u8 *fixed_buffer = NULL;
+static s32 usb2_inited = 0;
+
+#define ROUNDDOWN32(v)				(((u32)(v)-0x1f)&~0x1f)
+#define USB2_BUFFER 128*1024
+static heap_cntrl usb2_heap;
+static u8 __usb2_heap_created = 0;
+
+static DISC_INTERFACE __io_usb1storage;
+static int usb1disc_inited = 0;
+extern const DISC_INTERFACE __io_usb2storage;
+static int currentMode = 2; // 1 = use USB1 interface, 2 = use USB2 interface
+
+static s32 USB2CreateHeap()
+{
+	u32 level;
+	void *usb2_heap_ptr;
+
+	_CPU_ISR_Disable(level);
+
+	if (__usb2_heap_created != 0)
+	{
+		_CPU_ISR_Restore(level);
+		return IPC_OK;
+	}
+
+	usb2_heap_ptr = (void *) ROUNDDOWN32(((u32)SYS_GetArena2Hi() - (USB2_BUFFER+(4*1024))));
+	if ((u32) usb2_heap_ptr < (u32) SYS_GetArena2Lo())
+	{
+		_CPU_ISR_Restore(level);
+		return IPC_ENOMEM;
+	}
+	SYS_SetArena2Hi(usb2_heap_ptr);
+	__lwp_heap_init(&usb2_heap, usb2_heap_ptr, (USB2_BUFFER + (4 * 1024)), 32);
+	__usb2_heap_created = 1;
+	_CPU_ISR_Restore(level);
+	return IPC_OK;
+}
+
+static s32 USB2Storage_Initialize(int verbose)
+{	
+	s32 ret = USB_OK;
+	u32 size = 0;
+	char *devicepath = NULL;
+	
+	//if(usb2_inited)	return ret;
+
+	if (usb2_mutex == LWP_MUTEX_NULL)
+		LWP_MutexInit(&usb2_mutex, false);
+
+	LWP_MutexLock(usb2_mutex);
+
+	if (hId == -1)
+		hId = iosCreateHeap(UMS_HEAPSIZE);
+
+	if (hId < 0)
+	{
+		LWP_MutexUnlock(usb2_mutex);
+		debug_printf("error IPC_ENOMEM\n",fd);
+		return IPC_ENOMEM;
+	}
+
+	if (USB2CreateHeap() != IPC_OK)
+	{
+		debug_printf("error USB2 IPC_ENOMEM\n",fd);
+		return IPC_ENOMEM;
+	}
+
+	if (fixed_buffer == NULL)
+		fixed_buffer = __lwp_heap_allocate(&usb2_heap, USB2_BUFFER);
+
+	if (fd < 0)
+	{
+		devicepath = iosAlloc(hId, UMS_MAXPATH);
+		if (devicepath == NULL)
+		{
+			LWP_MutexUnlock(usb2_mutex);
+			return IPC_ENOMEM;
+		}
+
+		snprintf(devicepath, USB_MAXPATH, "/dev/usb2");
+		fd = IOS_Open(devicepath, 0);
+		iosFree(hId, devicepath);
+	}
+
+	ret = fd;
+	debug_printf("usb2 fd: %d\n",fd);
+	usleep(500);
+
+	if (fd > 0)
+	{
+		if (verbose)
+			ret = IOS_IoctlvFormat(hId, fd, USB_IOCTL_UMS_SET_VERBOSE, ":");
+		ret = IOS_IoctlvFormat(hId, fd, USB_IOCTL_UMS_INIT, ":");
+		debug_printf("usb2 init value: %i\n", ret);
+
+		if (ret < 0)
+			debug_printf("usb2 error init\n");
+		else
+			size = IOS_IoctlvFormat(hId, fd, USB_IOCTL_UMS_GET_CAPACITY, ":i",
+					&sector_size);
+		debug_printf("usb2 GET_CAPACITY: %d\n", size);
+
+		if (size == 0)
+			ret = -2012;
+		else
+			ret = 1;
+	}
+	else
+	{
+		ret = -1;
+	}
+
+	LWP_MutexUnlock(usb2_mutex);
+
+	if(ret >= 0)
+		usb2_inited = 1;
+
+	return ret;
+}
+
+static inline int is_MEM2_buffer(const void *buffer)
+{
+	u32 high_addr = ((u32) buffer) >> 24;
+	return (high_addr == 0x90) || (high_addr == 0xD0);
+}
+
+void USB2Enable(bool enable)
+{
+	if(!usb1disc_inited)
+	{
+		usb1disc_inited = 1;
+		memcpy(&__io_usb1storage, &__io_usbstorage, sizeof(DISC_INTERFACE));
+	}
+
+	if(!enable)
+	{
+		__io_usbstorage = __io_usb1storage;
+	}
+	else
+	{
+		//USB2Storage_Initialize(0);
+		__io_usbstorage = __io_usb2storage;
+	}
+}
+
+/*
+static s32 USB2Storage_Get_Capacity(u32*_sector_size)
+{
+	if(fd>0)
+	{
+		LWP_MutexLock(usb2_mutex);
+		s32 ret = IOS_IoctlvFormat(hId,fd,USB_IOCTL_UMS_GET_CAPACITY,":i",&sector_size);
+		if(_sector_size)
+			*_sector_size = sector_size;
+		LWP_MutexUnlock(usb2_mutex);
+		return ret;
+	}
+	else
+		return IPC_ENOENT;
+}
+
+s32 GetInitValue()
+{
+	return usb2_init_value;
+}
+
+s32 USB2Unmount()
+{
+	return IOS_IoctlvFormat(hId, fd, USB_IOCTL_UMS_UMOUNT, ":");
+}
+s32 USB2Start()
+{
+	return IOS_IoctlvFormat(hId, fd, USB_IOCTL_UMS_START, ":");
+}
+s32 USB2Stop()
+{
+	return IOS_IoctlvFormat(hId, fd, USB_IOCTL_UMS_STOP, ":");
+}
+
+void USB2Close()
+{
+	if (fd > 0)
+		IOS_Close(fd);
+	fd = -1;
+}
+
+int USB2ReadSector(u32 sector)
+{
+	void *b;
+	s32 ret;
+	b = malloc(1024);
+	ret = USBStorage_Read_Sectors(sector, 1, b);
+	free(b);
+	return ret;
+}
+*/
+
+static bool __usb2storage_Startup(void)
+{
+	bool ret;
+
+	usb2 = USB2Storage_Initialize(0);
+	
+	if(usb2 >= 0)
+	{
+		currentMode = 2;
+		ret = true;
+	}
+	else if (usb2 < 0)
+	{
+		ret = __io_usb1storage.startup();
+		
+		if(ret)
+			currentMode = 1;
+	}
+	return ret;
+}
+
+static bool __usb2storage_IsInserted(void)
+{
+	int retval;
+	bool ret = false;
+	
+	if (usb2 == -1)
+	{
+		retval = __usb2storage_Startup();
+		debug_printf("__usb2storage_Startup ret: %d  fd: %i\n",retval,fd);
+	}
+	//else 
+	LWP_MutexLock(usb2_mutex);
+	if (fd > 0)
+	{
+		
+		retval = IOS_IoctlvFormat(hId, fd, USB_IOCTL_UMS_IS_INSERTED, ":");
+		debug_printf("isinserted usb2 retval: %d  ret: %d\n",retval,ret);
+
+		if (retval > 0)
+		{
+			currentMode = 2;
+			ret = true;
+			debug_printf("isinserted(2) usb2 retval: %d  ret: %d\n",retval,ret);
+		}
+		
+	}
+	if(ret==false)
+	{
+		retval = __io_usb1storage.isInserted();
+
+		if (retval > 0)
+		{
+			debug_printf("isinserted usb1 retval: %d\n",retval);
+			currentMode = 1;
+			ret = true;
+		}
+	}
+	debug_printf("final isinserted usb2 retval: %d  ret: %d\n",retval,ret);
+	LWP_MutexUnlock(usb2_mutex);
+	return ret;
+}
+
+static bool __usb2storage_ReadSectors(u32 sector, u32 numSectors, void *buffer)
+{
+	s32 ret = 1;
+	u32 sectors = 0;
+	uint8_t *dest = buffer;
+	
+	if (currentMode == 1)
+		return __io_usb1storage.readSectors(sector, numSectors, buffer);
+
+	if (fd < 1)
+		return IPC_ENOENT;
+
+	LWP_MutexLock(usb2_mutex);
+
+	while (numSectors > 0)
+	{
+		if (numSectors * sector_size > USB2_BUFFER)
+			sectors = USB2_BUFFER / sector_size;
+		else
+			sectors = numSectors;
+
+		if (!is_MEM2_buffer(dest)) //libfat is not providing us good buffers :-(
+		{
+			ret = IOS_IoctlvFormat(hId, fd, USB_IOCTL_UMS_READ_SECTORS, "ii:d",
+					sector, sectors, fixed_buffer, sector_size * sectors);
+			memcpy(dest, fixed_buffer, sector_size * sectors);
+		}
+		else
+			ret = IOS_IoctlvFormat(hId, fd, USB_IOCTL_UMS_READ_SECTORS, "ii:d",
+					sector, sectors, dest, sector_size * sectors);
+
+		dest += sector_size * sectors;
+		if (ret < 1) break;
+
+		sector += sectors;
+		numSectors -= sectors;
+	}
+	if(ret<1)usb2 = -1;
+	LWP_MutexUnlock(usb2_mutex);
+	if (ret < 1) return false;
+	return true;
+}
+
+static bool __usb2storage_WriteSectors(u32 sector, u32 numSectors, const void *buffer)
+{
+	s32 ret = 1;
+	u32 sectors = 0;
+	uint8_t *dest = (uint8_t *) buffer;
+	
+	if (currentMode == 1)
+		return __io_usb1storage.writeSectors(sector, numSectors, buffer);
+	
+	if (fd < 1)
+		return IPC_ENOENT;
+
+	LWP_MutexLock(usb2_mutex);
+	while (numSectors > 0 && ret > 0)
+	{
+		if (numSectors * sector_size > USB2_BUFFER)
+			sectors = USB2_BUFFER / sector_size;
+		else
+			sectors = numSectors;
+
+		numSectors -= sectors;
+
+		if (!is_MEM2_buffer(dest)) // libfat is not providing us good buffers :-(
+		{
+			memcpy(fixed_buffer, dest, sector_size * sectors);
+			ret = IOS_IoctlvFormat(hId, fd, USB_IOCTL_UMS_WRITE_SECTORS,
+					"ii:d", sector, sectors, fixed_buffer, sector_size
+							* sectors);
+		}
+		else
+			ret = IOS_IoctlvFormat(hId, fd, USB_IOCTL_UMS_WRITE_SECTORS,
+					"ii:d", sector, sectors, dest, sector_size * sectors);
+		if (ret < 1)break;
+
+		dest += sector_size * sectors;
+		sector += sectors;
+	}
+	LWP_MutexUnlock(usb2_mutex);
+	if(ret < 1 ) return false;
+	return true;
+}
+
+static bool __usb2storage_ClearStatus(void)
+{
+	if (currentMode == 1)
+		return __io_usb1storage.clearStatus();
+
+	return true;
+}
+
+static bool __usb2storage_Shutdown(void)
+{
+	if (currentMode == 1)
+		return __io_usb1storage.shutdown();
+
+	LWP_MutexLock(usb2_mutex);
+	debug_printf("__usb2storage_Shutdown\n");
+	usb2 = -1;
+	LWP_MutexUnlock(usb2_mutex);
+	return true;
+}
+
+const DISC_INTERFACE __io_usb2storage = { 
+	DEVICE_TYPE_WII_USB, 
+	FEATURE_MEDIUM_CANREAD | FEATURE_MEDIUM_CANWRITE | FEATURE_WII_USB, 
+	(FN_MEDIUM_STARTUP) & __usb2storage_Startup,
+	(FN_MEDIUM_ISINSERTED) & __usb2storage_IsInserted,
+	(FN_MEDIUM_READSECTORS) & __usb2storage_ReadSectors,
+	(FN_MEDIUM_WRITESECTORS) & __usb2storage_WriteSectors,
+	(FN_MEDIUM_CLEARSTATUS) & __usb2storage_ClearStatus,
+	(FN_MEDIUM_SHUTDOWN) & __usb2storage_Shutdown
+};
+#endif
Index: source/gx/utils/mload.h
===================================================================
--- source/gx/utils/mload.h	(revision 0)
+++ source/gx/utils/mload.h	(revision 441)
@@ -0,0 +1,33 @@
+/* mload.c (for PPC) (c) 2009, Hermes 
+
+  This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+#ifndef __MLOAD_H__
+#define __MLOAD_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int mload_init();
+bool load_ehci_module();
+int mload_close();
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
Index: source/gx/utils/vi_encoder.h
===================================================================
--- source/gx/utils/vi_encoder.h	(revision 0)
+++ source/gx/utils/vi_encoder.h	(revision 441)
@@ -0,0 +1,64 @@
+/****************************************************************************
+ *  vi_encoder.c
+ *
+ *  Wii Audio/Video Encoder support
+ *
+ *  Copyright (C) 2009 Hector Martin (marcan)
+ *  Additional code by Eke-Eke
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ***************************************************************************/
+#ifdef HW_RVL
+
+typedef enum
+{
+    VI_GM_0_1=1,
+    VI_GM_0_2,
+    VI_GM_0_3,
+    VI_GM_0_4,
+    VI_GM_0_5,
+    VI_GM_0_6,
+    VI_GM_0_7,
+    VI_GM_0_8,
+    VI_GM_0_9,
+    VI_GM_1_0,
+    VI_GM_1_1,
+    VI_GM_1_2,
+    VI_GM_1_3,
+    VI_GM_1_4,
+    VI_GM_1_5,
+    VI_GM_1_6,
+    VI_GM_1_7,
+    VI_GM_1_8,
+    VI_GM_1_9,
+    VI_GM_2_0,
+    VI_GM_2_1,
+    VI_GM_2_2,
+    VI_GM_2_3,
+    VI_GM_2_4,
+    VI_GM_2_5,
+    VI_GM_2_6,
+    VI_GM_2_7,
+    VI_GM_2_8,
+    VI_GM_2_9,
+    VI_GM_3_0
+} VIGamma;
+
+extern void VIDEO_SetGamma(VIGamma gamma);
+extern void VIDEO_SetTrapFilter(bool enable);
+
+
+#endif
Index: source/gx/utils/usb2storage.h
===================================================================
--- source/gx/utils/usb2storage.h	(revision 0)
+++ source/gx/utils/usb2storage.h	(revision 441)
@@ -0,0 +1,16 @@
+
+#ifndef __USB2STORAGE_H__
+#define __USB2STORAGE_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+void USB2Enable(bool enable);
+
+#ifdef __cplusplus
+  }
+#endif
+
+
+#endif
Index: source/gx/utils/oggplayer.c
===================================================================
--- source/gx/utils/oggplayer.c	(revision 0)
+++ source/gx/utils/oggplayer.c	(revision 441)
@@ -0,0 +1,536 @@
+/*
+ Copyright (c) 2008 Francisco Muñoz 'Hermes' <www.elotrolado.net>
+ All rights reserved.
+
+ Proper (standard) vorbis usage by Tantric, 2009
+ Threading modifications/corrections by Tantric, 2009
+
+ Redistribution and use in source and binary forms, with or without modification, are
+ permitted provided that the following conditions are met:
+
+ - Redistributions of source code must retain the above copyright notice, this list of
+ conditions and the following disclaimer.
+ - Redistributions in binary form must reproduce the above copyright notice, this list
+ of conditions and the following disclaimer in the documentation and/or other
+ materials provided with the distribution.
+ - The names of the contributors may not be used to endorse or promote products derived
+ from this software without specific prior written permission.
+
+ THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
+ EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
+ THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+ PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
+ THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "oggplayer.h"
+#include <gccore.h>
+#include <unistd.h>
+#include <string.h>
+
+/* functions to read the Ogg file from memory */
+
+static struct
+{
+  char *mem;
+  int size;
+  int pos;
+} file[4];
+
+static int f_read(void * punt, int bytes, int blocks, int *f)
+{
+  int b;
+  int c;
+  int d;
+
+  if (bytes * blocks <= 0)
+    return 0;
+
+  blocks = bytes * blocks;
+  c = 0;
+
+  while (blocks > 0)
+  {
+    b = blocks;
+    if (b > 4096)
+      b = 4096;
+
+    if (*f >= 0x666 && *f <= 0x669)
+    {
+      d = (*f) - 0x666;
+      if (file[d].size == 0)
+        return -1;
+      if ((file[d].pos + b) > file[d].size)
+        b = file[d].size - file[d].pos;
+      if (b > 0)
+      {
+        memcpy(punt, file[d].mem + file[d].pos, b);
+        file[d].pos += b;
+      }
+    }
+    else
+      b = read(*f, ((char *) punt) + c, b);
+
+    if (b <= 0)
+    {
+      return c / bytes;
+    }
+    c += b;
+    blocks -= b;
+  }
+  return c / bytes;
+}
+
+static int f_seek(int *f, ogg_int64_t offset, int mode)
+{
+  if(f==NULL) return(-1);
+
+  int k, d;
+  mode &= 3;
+  if (*f >= 0x666 && *f <= 0x669)
+  {
+    d = (*f) - 0x666;
+    k = 0;
+
+    if (file[d].size == 0)
+      return -1;
+
+    if (mode == 0)
+    {
+      if ((offset) >= file[d].size)
+      {
+        file[d].pos = file[d].size;
+        k = -1;
+      }
+      else if ((offset) < 0)
+      {
+        file[d].pos = 0;
+        k = -1;
+      }
+      else
+        file[d].pos = offset;
+    }
+    if (mode == 1)
+    {
+      if ((file[d].pos + offset) >= file[d].size)
+      {
+        file[d].pos = file[d].size;
+        k = -1;
+      }
+      else if ((file[d].pos + offset) < 0)
+      {
+        file[d].pos = 0;
+        k = -1;
+      }
+      else
+        file[d].pos += offset;
+    }
+    if (mode == 2)
+    {
+
+      if ((file[d].size + offset) >= file[d].size)
+      {
+        file[d].pos = file[d].size;
+        k = -1;
+      }
+      else if ((file[d].size + offset) < 0)
+      {
+        file[d].pos = 0;
+        k = -1;
+      }
+      else
+        file[d].pos = file[d].size + offset;
+    }
+
+  }
+  else
+    k = lseek(*f, (int) offset, mode);
+
+  if (k < 0)
+    k = -1;
+  else
+    k = 0;
+  return k;
+}
+
+static int f_close(int *f)
+{
+  int d;
+  if (*f >= 0x666 && *f <= 0x669)
+  {
+    d = (*f) - 0x666;
+    file[d].size = 0;
+    file[d].pos = 0;
+    if (file[d].mem)
+    {
+      file[d].mem = (void *) 0;
+    }
+    return 0;
+  }
+  else
+    return close(*f);
+  return 0;
+}
+
+static long f_tell(int *f)
+{
+  int k, d;
+
+  if (*f >= 0x666 && *f <= 0x669)
+  {
+    d = (*f) - 0x666;
+    k = file[d].pos;
+  }
+  else
+    k = lseek(*f, 0, 1);
+
+  return (long) k;
+}
+
+static int mem_open(char * ogg, int size)
+{
+  static int one = 1;
+  int n;
+  if (one)
+  {
+    one = 0;
+    for (n = 0; n < 4; n++)
+      file[n].size = 0;
+  }
+
+  for (n = 0; n < 4; n++)
+  {
+    if (file[n].size == 0)
+    {
+      file[n].mem = ogg;
+      file[n].size = size;
+      file[n].pos = 0;
+      return (0x666 + n);
+    }
+  }
+  return -1;
+}
+
+static int mem_close(int fd)
+{
+  if (fd >= 0x666 && fd <= 0x669) // it is a memory file descriptor?
+  {
+    fd -= 0x666;
+    file[fd].size = 0;
+    return 0;
+  }
+  else
+    return f_close(&fd);
+}
+
+static ov_callbacks callbacks = {
+  (size_t (*)(void *, size_t, size_t, void *))  f_read,
+  (int (*)(void *, ogg_int64_t, int))           f_seek,
+  (int (*)(void *))                             f_close,
+  (long (*)(void *))                            f_tell
+};
+
+/* OGG control */
+
+#define READ_SAMPLES 4096 /* samples that it must read before to send */
+#define MAX_PCMOUT 4096 /* minimum size to read ogg samples */
+typedef struct
+{
+  OggVorbis_File vf;
+  vorbis_info *vi;
+  int current_section;
+
+  /* OGG file operation */
+  int fd;
+  int mode;
+  int eof;
+  int flag;
+  int volume;
+  int seek_time;
+
+  /* OGG buffer control */
+  short pcmout[2][READ_SAMPLES + MAX_PCMOUT * 2]; /* take 4k out of the data segment, not the stack */
+  int pcmout_pos;
+  int pcm_indx;
+
+} private_data_ogg;
+
+static private_data_ogg private_ogg;
+
+/* OGG thread control */
+
+#define STACKSIZE    8192
+
+static u8 oggplayer_stack[STACKSIZE];
+static lwpq_t oggplayer_queue = LWP_TQUEUE_NULL;
+static lwp_t h_oggplayer = LWP_THREAD_NULL;
+static int ogg_thread_running = 0;
+
+static void ogg_add_callback(int voice)
+{
+  if (!ogg_thread_running)
+  {
+    ASND_StopVoice(0);
+    return;
+  }
+
+  if (private_ogg.flag & 128)
+    return; /* Ogg is paused */
+
+  if (private_ogg.pcm_indx >= READ_SAMPLES)
+  {
+    if (ASND_AddVoice(0,
+        (void *) private_ogg.pcmout[private_ogg.pcmout_pos],
+        private_ogg.pcm_indx << 1) == 0)
+    {
+      private_ogg.pcmout_pos ^= 1;
+      private_ogg.pcm_indx = 0;
+      private_ogg.flag = 0;
+      LWP_ThreadSignal(oggplayer_queue);
+    }
+  }
+  else
+  {
+    if (private_ogg.flag & 64)
+    {
+      private_ogg.flag &= ~64;
+      LWP_ThreadSignal(oggplayer_queue);
+    }
+  }
+}
+
+static void * ogg_player_thread(private_data_ogg * priv)
+{
+  int first_time = 1;
+  long ret;
+
+  /* init */
+  LWP_InitQueue(&oggplayer_queue);
+
+  priv[0].vi = ov_info(&priv[0].vf, -1);
+
+  ASND_Pause(0);
+
+  priv[0].pcm_indx = 0;
+  priv[0].pcmout_pos = 0;
+  priv[0].eof = 0;
+  priv[0].flag = 0;
+  priv[0].current_section = 0;
+
+  ogg_thread_running = 1;
+
+  while (!priv[0].eof && ogg_thread_running)
+  {
+    if (priv[0].flag)
+      LWP_ThreadSleep(oggplayer_queue); /* wait only when i have samples to send */
+
+    if (priv[0].flag == 0) /* wait to all samples are sended */
+    {
+      if (ASND_TestPointer(0, priv[0].pcmout[priv[0].pcmout_pos])
+          && ASND_StatusVoice(0) != SND_UNUSED)
+      {
+        priv[0].flag |= 64;
+        continue;
+      }
+      if (priv[0].pcm_indx < READ_SAMPLES)
+      {
+        priv[0].flag = 3;
+
+        if (priv[0].seek_time >= 0)
+        {
+          ov_time_seek(&priv[0].vf, priv[0].seek_time);
+          priv[0].seek_time = -1;
+        }
+
+        ret
+            = ov_read(
+                &priv[0].vf,
+                (void *) &priv[0].pcmout[priv[0].pcmout_pos][priv[0].pcm_indx],
+                MAX_PCMOUT,/*0,2,1,*/&priv[0].current_section);
+        priv[0].flag &= 192;
+        if (ret == 0)
+        {
+          /* EOF */
+          if (priv[0].mode & 1)
+            ov_time_seek(&priv[0].vf, 0); /* repeat */
+          else
+            priv[0].eof = 1; /* stops */
+        }
+        else if (ret < 0)
+        {
+          /* error in the stream.  Not a problem, just reporting it in
+           case we (the app) cares.  In this case, we don't. */
+          if (ret != OV_HOLE)
+          {
+            if (priv[0].mode & 1)
+              ov_time_seek(&priv[0].vf, 0); /* repeat */
+            else
+              priv[0].eof = 1; /* stops */
+          }
+        }
+        else
+        {
+          /* we don't bother dealing with sample rate changes, etc, but
+           you'll have to */
+          priv[0].pcm_indx += ret >> 1; /* get 16 bits samples */
+        }
+      }
+      else
+        priv[0].flag = 1;
+    }
+
+    if (priv[0].flag == 1)
+    {
+      if (ASND_StatusVoice(0) == SND_UNUSED || first_time)
+      {
+        first_time = 0;
+        if (priv[0].vi->channels == 2)
+        {
+          ASND_SetVoice(0, VOICE_STEREO_16BIT, priv[0].vi->rate, 0,
+              (void *) priv[0].pcmout[priv[0].pcmout_pos],
+              priv[0].pcm_indx << 1, priv[0].volume,
+              priv[0].volume, ogg_add_callback);
+          priv[0].pcmout_pos ^= 1;
+          priv[0].pcm_indx = 0;
+          priv[0].flag = 0;
+        }
+        else
+        {
+          ASND_SetVoice(0, VOICE_MONO_16BIT, priv[0].vi->rate, 0,
+              (void *) priv[0].pcmout[priv[0].pcmout_pos],
+              priv[0].pcm_indx << 1, priv[0].volume,
+              priv[0].volume, ogg_add_callback);
+          priv[0].pcmout_pos ^= 1;
+          priv[0].pcm_indx = 0;
+          priv[0].flag = 0;
+        }
+      }
+    }
+    usleep(10);
+  }
+  ov_clear(&priv[0].vf);
+  priv[0].fd = -1;
+  priv[0].pcm_indx = 0;
+
+  return 0;
+}
+
+void StopOgg()
+{
+  ASND_StopVoice(0);
+  ogg_thread_running = 0;
+
+  if(h_oggplayer != LWP_THREAD_NULL)
+  {
+    if(oggplayer_queue != LWP_TQUEUE_NULL)
+      LWP_ThreadSignal(oggplayer_queue);
+    LWP_JoinThread(h_oggplayer, NULL);
+    h_oggplayer = LWP_THREAD_NULL;
+  }
+  if(oggplayer_queue != LWP_TQUEUE_NULL)
+  {
+    LWP_CloseQueue(oggplayer_queue);
+    oggplayer_queue = LWP_TQUEUE_NULL;
+  }
+}
+
+int PlayOgg(char * buf, int buflen, int time_pos, int mode)
+{
+  StopOgg();
+
+  private_ogg.fd = mem_open(buf, buflen);
+  
+  if (private_ogg.fd < 0)
+  {
+    private_ogg.fd = -1;
+    return -1;
+  }
+
+  private_ogg.mode = mode;
+  private_ogg.eof = 0;
+  private_ogg.volume = 127;
+  private_ogg.flag = 0;
+  private_ogg.seek_time = -1;
+
+  if (time_pos > 0)
+    private_ogg.seek_time = time_pos;
+
+  if (ov_open_callbacks((void *) &private_ogg.fd, &private_ogg.vf, NULL, 0, callbacks) < 0)
+  {
+    mem_close(private_ogg.fd); /* mem_close() can too close files from devices */
+    private_ogg.fd = -1;
+    ogg_thread_running = 0;
+    return -1;
+  }
+
+  if (LWP_CreateThread(&h_oggplayer, (void *) ogg_player_thread,
+      &private_ogg, oggplayer_stack, STACKSIZE, 80) == -1)
+  {
+    ogg_thread_running = 0;
+    ov_clear(&private_ogg.vf);
+    private_ogg.fd = -1;
+    return -1;
+  }
+  return 0;
+}
+
+void PauseOgg(int pause)
+{
+  if (pause)
+  {
+    private_ogg.flag |= 128;
+  }
+  else
+  {
+    if (private_ogg.flag & 128)
+    {
+      private_ogg.flag |= 64;
+      private_ogg.flag &= ~128;
+      if (ogg_thread_running > 0)
+      {
+        LWP_ThreadSignal(oggplayer_queue);
+      }
+    }
+  }
+}
+
+int StatusOgg()
+{
+  if (ogg_thread_running == 0)
+    return -1; /* Error */
+  else if (private_ogg.eof)
+    return 255; /* EOF */
+  else if (private_ogg.flag & 128)
+    return 2; /* paused */
+  else
+    return 1; /* running */
+}
+
+void SetVolumeOgg(int volume)
+{
+  private_ogg.volume = volume;
+  ASND_ChangeVolumeVoice(0, volume, volume);
+}
+
+s32 GetTimeOgg()
+{
+  int ret;
+  if (ogg_thread_running == 0 || private_ogg.fd < 0)
+    return 0;
+  ret = ((s32) ov_time_tell(&private_ogg.vf));
+  if (ret < 0)
+    ret = 0;
+
+  return ret;
+}
+
+void SetTimeOgg(s32 time_pos)
+{
+  if (time_pos >= 0)
+    private_ogg.seek_time = time_pos;
+}
+
Index: source/gx/utils/mload.c
===================================================================
--- source/gx/utils/mload.c	(revision 0)
+++ source/gx/utils/mload.c	(revision 441)
@@ -0,0 +1,281 @@
+/* mload.c (for PPC) (c) 2009, Hermes 
+
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#ifdef HW_RVL
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <ogcsys.h>
+#include <gccore.h>
+#include <ogc/ipc.h>
+#include "unistd.h"
+#include "ehcmodule_elf.h"
+
+#define MLOAD_MLOAD_THREAD_ID	0x4D4C4400
+#define MLOAD_LOAD_MODULE		0x4D4C4480
+#define MLOAD_RUN_MODULE		0x4D4C4481
+#define MLOAD_RUN_THREAD        0x4D4C4482
+
+#define MLOAD_STOP_THREAD		0x4D4C4484
+#define MLOAD_CONTINUE_THREAD   0x4D4C4485
+
+#define MLOAD_GET_LOAD_BASE     0x4D4C4490
+#define MLOAD_MEMSET			0x4D4C4491
+
+#define MLOAD_GET_EHCI_DATA		0x4D4C44A0
+
+#define MLOAD_SET_ES_IOCTLV		0x4D4C44B0
+
+#define getbe32(x) ((adr[x]<<24) | (adr[x+1]<<16) | (adr[x+2]<<8) | (adr[x+3]))
+
+typedef struct
+{
+	u32 ident0;
+	u32 ident1;
+	u32 ident2;
+	u32 ident3;
+	u32 machinetype;
+	u32 version;
+	u32 entry;
+	u32 phoff;
+	u32 shoff;
+	u32 flags;
+	u16 ehsize;
+	u16 phentsize;
+	u16 phnum;
+	u16 shentsize;
+	u16 shnum;
+	u16 shtrndx;
+} elfheader;
+
+typedef struct
+{
+	u32 type;
+	u32 offset;
+	u32 vaddr;
+	u32 paddr;
+	u32 filesz;
+	u32 memsz;
+	u32 flags;
+	u32 align;
+} elfphentry;
+
+typedef struct
+{
+	void *start;
+	int prio;
+	void *stack;
+	int size_stack;
+} data_elf;
+
+static const char mload_fs[] ATTRIBUTE_ALIGN(32) = "/dev/mload";
+static s32 mload_fd = -1;
+
+// to init/test if the device is running
+int mload_init()
+{
+	int n;
+
+	if (mload_fd >= 0)
+		return 0;
+
+	for (n = 0; n < 10; n++) // try 2.5 seconds
+	{
+		mload_fd = IOS_Open(mload_fs, 0);
+
+		if (mload_fd >= 0)
+			break;
+
+		usleep(250 * 1000);
+	}
+
+	return mload_fd;
+}
+
+// to close the device (remember call it when rebooting the IOS!)
+int mload_close()
+{
+	int ret;
+
+	if (mload_fd < 0)
+		return -1;
+
+	ret = IOS_Close(mload_fd);
+
+	mload_fd = -1;
+
+	return ret;
+}
+
+// fix starlet address to read/write (uses SEEK_SET, etc as mode)
+static int mload_seek(int offset, int mode)
+{
+	if (mload_init() < 0)
+		return -1;
+	return IOS_Seek(mload_fd, offset, mode);
+}
+
+// write bytes from starlet (it update the offset)
+static int mload_write(const void * buf, u32 size)
+{
+	if (mload_init() < 0)
+		return -1;
+	return IOS_Write(mload_fd, buf, size);
+}
+
+// fill a block (similar to memset)
+static int mload_memset(void *starlet_addr, int set, int len)
+{
+	int ret;
+	s32 hid = -1;
+
+	if (mload_init() < 0)
+		return -1;
+
+	hid = iosCreateHeap(0x800);
+
+	if (hid < 0)
+		return hid;
+
+	ret = IOS_IoctlvFormat(hid, mload_fd, MLOAD_MEMSET, "iii:", starlet_addr,
+			set, len);
+
+	iosDestroyHeap(hid);
+
+	return ret;
+}
+
+// load a module from the PPC
+// the module must be a elf made with stripios
+static int mload_elf(void *my_elf, data_elf *data_elf)
+{
+	int n, m;
+	int p;
+	u8 *adr;
+	u32 elf = (u32) my_elf;
+
+	if (elf & 3)
+		return -1; // aligned to 4 please!
+
+	elfheader *head = (void *) elf;
+	elfphentry *entries;
+
+	if (head->ident0 != 0x7F454C46)
+		return -1;
+	if (head->ident1 != 0x01020161)
+		return -1;
+	if (head->ident2 != 0x01000000)
+		return -1;
+
+	p = head->phoff;
+
+	data_elf->start = (void *) head->entry;
+
+	for (n = 0; n < head->phnum; n++)
+	{
+		entries = (void *) (elf + p);
+		p += sizeof(elfphentry);
+
+		if (entries->type == 4)
+		{
+			adr = (void *) (elf + entries->offset);
+
+			if (getbe32(0) != 0)
+				return -2; // bad info (sure)
+
+			for (m = 4; m < entries->memsz; m += 8)
+			{
+				switch (getbe32(m))
+				{
+				case 0x9:
+					data_elf->start = (void *) getbe32(m+4);
+					break;
+				case 0x7D:
+					data_elf->prio = getbe32(m+4);
+					break;
+				case 0x7E:
+					data_elf->size_stack = getbe32(m+4);
+					break;
+				case 0x7F:
+					data_elf->stack = (void *) (getbe32(m+4));
+					break;
+
+				}
+			}
+		}
+		else if (entries->type == 1 && entries->memsz != 0 && entries->vaddr != 0)
+		{
+
+			if (mload_memset((void *) entries->vaddr, 0, entries->memsz) < 0)
+				return -1;
+			if (mload_seek(entries->vaddr, SEEK_SET) < 0)
+				return -1;
+			if (mload_write((void *) (elf + entries->offset), entries->filesz) < 0)
+				return -1;
+		}
+	}
+
+	return 0;
+}
+
+// run one thread (you can use to load modules or binary files)
+static int mload_run_thread(void *starlet_addr, void *starlet_top_stack,
+		int stack_size, int priority)
+{
+	int ret;
+	s32 hid = -1;
+
+	if (mload_init() < 0)
+		return -1;
+
+	hid = iosCreateHeap(0x800);
+
+	if (hid < 0)
+		return hid;
+
+	ret = IOS_IoctlvFormat(hid, mload_fd, MLOAD_RUN_THREAD, "iiii:",
+			starlet_addr, starlet_top_stack, stack_size, priority);
+
+	iosDestroyHeap(hid);
+
+	return ret;
+}
+
+bool load_ehci_module()
+{
+	data_elf my_data_elf;
+	my_data_elf.start = NULL;
+	my_data_elf.prio = 0;
+	my_data_elf.stack = NULL;
+	my_data_elf.size_stack = 0;
+
+	if(mload_elf((void *) ehcmodule_elf, &my_data_elf) != 0)
+		return false;
+
+	if (mload_run_thread(my_data_elf.start, my_data_elf.stack,
+			my_data_elf.size_stack, my_data_elf.prio) < 0)
+	{
+		usleep(1000);
+		if (mload_run_thread(my_data_elf.start, my_data_elf.stack,
+				my_data_elf.size_stack, 0x47) < 0)
+			return false;
+	}
+	return true;
+}
+
+#endif
Index: source/gx/utils/vi_encoder.c
===================================================================
--- source/gx/utils/vi_encoder.c	(revision 0)
+++ source/gx/utils/vi_encoder.c	(revision 441)
@@ -0,0 +1,549 @@
+/****************************************************************************
+ *  vi_encoder.c
+ *
+ *  Wii Audio/Video Encoder support
+ *
+ *  Copyright (C) 2009 Hector Martin (marcan)
+ *  Additional code by Eke-Eke
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ ***************************************************************************/
+#ifdef HW_RVL
+
+#include <string.h>
+#include <gccore.h>
+#include <ogcsys.h>
+#include <ogc/machine/processor.h>
+
+#include "vi_encoder.h"
+
+/****************************************************************************
+ *  I2C driver by Hector Martin (marcan)
+ *
+ ****************************************************************************/
+
+#define _SHIFTL(v, s, w)	\
+    ((u32) (((u32)(v) & ((0x01 << (w)) - 1)) << (s)))
+#define _SHIFTR(v, s, w)	\
+    ((u32)(((u32)(v) >> (s)) & ((0x01 << (w)) - 1)))
+
+extern void udelay(int us);
+
+static u32 i2cIdentFirst = 0;
+static u32 i2cIdentFlag = 1;
+static vu16* const _viReg = (u16*)0xCC002000;
+static vu32* const _i2cReg = (u32*)0xCD800000;
+
+static inline void __viOpenI2C(u32 channel)
+{
+	u32 val = ((_i2cReg[49]&~0x8000)|0x4000);
+	val |= _SHIFTL(channel,15,1);
+	_i2cReg[49] = val;
+}
+
+static inline u32 __viSetSCL(u32 channel)
+{
+	u32 val = (_i2cReg[48]&~0x4000);
+	val |= _SHIFTL(channel,14,1);
+	_i2cReg[48] = val;
+	return 1;
+}
+static inline u32 __viSetSDA(u32 channel)
+{
+	u32 val = (_i2cReg[48]&~0x8000);
+	val |= _SHIFTL(channel,15,1);
+	_i2cReg[48] = val;
+	return 1;
+}
+
+static inline u32 __viGetSDA()
+{
+	return _SHIFTR(_i2cReg[50],15,1);
+}
+
+static inline void __viCheckI2C()
+{
+	__viOpenI2C(0);
+	udelay(4);
+
+	i2cIdentFlag = 0;
+	if(__viGetSDA()!=0) i2cIdentFlag = 1;
+}
+
+static u32 __sendSlaveAddress(u8 addr)
+{
+	u32 i;
+
+	__viSetSDA(i2cIdentFlag^1);
+	udelay(2);
+
+	__viSetSCL(0);
+	for(i=0;i<8;i++) {
+		if(addr&0x80) __viSetSDA(i2cIdentFlag);
+		else __viSetSDA(i2cIdentFlag^1);
+		udelay(2);
+
+		__viSetSCL(1);
+		udelay(2);
+
+		__viSetSCL(0);
+		addr <<= 1;
+	}
+
+	__viOpenI2C(0);
+	udelay(2);
+
+	__viSetSCL(1);
+	udelay(2);
+
+	if(i2cIdentFlag==1 && __viGetSDA()!=0) return 0;
+
+	__viSetSDA(i2cIdentFlag^1);
+	__viOpenI2C(1);
+	__viSetSCL(0);
+
+	return 1;
+}
+
+static u32 __VISendI2CData(u8 addr,void *val,u32 len)
+{
+	u8 c;
+	s32 i,j;
+	u32 level,ret;
+
+	if(i2cIdentFirst==0) {
+		__viCheckI2C();
+		i2cIdentFirst = 1;
+	}
+
+	_CPU_ISR_Disable(level);
+
+	__viOpenI2C(1);
+	__viSetSCL(1);
+
+	__viSetSDA(i2cIdentFlag);
+	udelay(4);
+
+	ret = __sendSlaveAddress(addr);
+	if(ret==0) {
+		_CPU_ISR_Restore(level);
+		return 0;
+	}
+
+	__viOpenI2C(1);
+	for(i=0;i<len;i++) {
+		c = ((u8*)val)[i];
+		for(j=0;j<8;j++) {
+			if(c&0x80) __viSetSDA(i2cIdentFlag);
+			else __viSetSDA(i2cIdentFlag^1);
+			udelay(2);
+
+			__viSetSCL(1);
+			udelay(2);
+			__viSetSCL(0);
+
+			c <<= 1;
+		}
+		__viOpenI2C(0);
+		udelay(2);
+		__viSetSCL(1);
+		udelay(2);
+
+		if(i2cIdentFlag==1 && __viGetSDA()!=0) {
+			_CPU_ISR_Restore(level);
+			return 0;
+		}
+
+		__viSetSDA(i2cIdentFlag^1);
+		__viOpenI2C(1);
+		__viSetSCL(0);
+	}
+
+	__viOpenI2C(1);
+	__viSetSDA(i2cIdentFlag^1);
+	udelay(2);
+	__viSetSDA(i2cIdentFlag);
+
+	_CPU_ISR_Restore(level);
+	return 1;
+}
+
+static void __VIWriteI2CRegister8(u8 reg, u8 data)
+{
+	u8 buf[2];
+	buf[0] = reg;
+	buf[1] = data;
+	__VISendI2CData(0xe0,buf,2);
+	udelay(2);
+}
+
+static void __VIWriteI2CRegister16(u8 reg, u16 data)
+{
+	u8 buf[3];
+	buf[0] = reg;
+	buf[1] = data >> 8;
+	buf[2] = data & 0xFF;
+	__VISendI2CData(0xe0,buf,3);
+	udelay(2);
+}
+
+static void __VIWriteI2CRegister32(u8 reg, u32 data)
+{
+	u8 buf[5];
+	buf[0] = reg;
+	buf[1] = data >> 24;
+	buf[2] = (data >> 16) & 0xFF;
+	buf[3] = (data >> 8) & 0xFF;
+	buf[4] = data & 0xFF;
+	__VISendI2CData(0xe0,buf,5);
+	udelay(2);
+}
+
+static void __VIWriteI2CRegisterBuf(u8 reg, int size, u8 *data)
+{
+	u8 buf[0x100];
+	buf[0] = reg;
+	memcpy(&buf[1], data, size);
+	__VISendI2CData(0xe0,buf,size+1);
+	udelay(2);
+}
+
+/****************************************************************************
+ *  A/V functions support (Eke-Eke)
+ *
+ ****************************************************************************/
+static const u8 gamma_coeffs[][33] =
+{
+	/* GM_0_0 */
+	{
+		 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+ 
+	},	
+ 
+	/* GM_0_1 */
+	{
+		 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x03, 0x97, 0x3B, 0x49,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x80, 0x1B, 0x80, 0xEB, 0x00
+	},	
+ 
+	/* GM_0_2 */
+	{
+		 0x00, 0x00, 0x00, 0x28, 0x00, 0x5A, 0x02, 0xDB, 0x0D, 0x8D, 0x30, 0x49,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x10, 0x00, 0x10, 0x40, 0x11, 0x00, 0x18, 0x80, 0x42, 0x00, 0xEB, 0x00
+	},	
+ 
+	/* GM_0_3 */
+	{
+		 0x00, 0x00, 0x00, 0x7A, 0x02, 0x3C, 0x07, 0x6D, 0x12, 0x9C, 0x27, 0x24,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x10, 0x00, 0x10, 0xC0, 0x15, 0x80, 0x29, 0x00, 0x62, 0x00, 0xEB, 0x00
+	},	
+ 
+	/* GM_0_4 */
+	{
+		 0x00, 0x4E, 0x01, 0x99, 0x05, 0x2D, 0x0B, 0x24, 0x14, 0x29, 0x20, 0xA4,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x00, 0x10, 0x10, 0x40, 0x12, 0xC0, 0x1D, 0xC0, 0x3B, 0x00, 0x78, 0xC0, 0xEB, 0x00
+	},	
+ 
+	/* GM_0_5 */
+	{
+		 0x00, 0xEC, 0x03, 0xD7, 0x08, 0x00, 0x0D, 0x9E, 0x14, 0x3E, 0x1B, 0xDB,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x10, 0xC0, 0x16, 0xC0, 0x27, 0xC0, 0x4B, 0x80, 0x89, 0x80, 0xEB, 0x00
+	},	
+ 
+	/* GM_0_6 */
+	{
+		 0x02, 0x76, 0x06, 0x66, 0x0A, 0x96, 0x0E, 0xF3, 0x13, 0xAC, 0x18, 0x49,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB, 
+		 0x10, 0x00, 0x12, 0x00, 0x1C, 0x00, 0x32, 0x80, 0x59, 0xC0, 0x96, 0x00, 0xEB, 0x00
+	},	
+ 
+	/* GM_0_7 */
+	{
+		 0x04, 0xEC, 0x08, 0xF5, 0x0C, 0x96, 0x0F, 0xCF, 0x12, 0xC6, 0x15, 0x80,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB, 
+		 0x10, 0x00, 0x14, 0x00, 0x22, 0x00, 0x3C, 0xC0, 0x66, 0x40, 0x9F, 0xC0, 0xEB, 0x00
+	},	
+ 
+	/* GM_0_8 */
+	{
+		 0x08, 0x00, 0x0B, 0xAE, 0x0E, 0x00, 0x10, 0x30, 0x11, 0xCB, 0x13, 0x49,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB, 
+		 0x10, 0x00, 0x16, 0x80, 0x28, 0xC0, 0x46, 0x80, 0x71, 0x00, 0xA7, 0x80, 0xEB, 0x00
+	},	
+ 
+	/* GM_0_9 */
+	{
+		 0x0B, 0xB1, 0x0E, 0x14, 0x0F, 0x2D, 0x10, 0x18, 0x10, 0xE5, 0x11, 0x80,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x19, 0x80, 0x2F, 0x80, 0x4F, 0xC0, 0x7A, 0x00, 0xAD, 0xC0, 0xEB, 0x00
+	},	
+ 
+	/* GM_1_0 */
+	{
+		 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00, 0x10, 0x00,
+		 0x10, 0x20, 0x40, 0x60, 0x80, 0xA0, 0xEB,
+		 0x10, 0x00, 0x20, 0x00, 0x40, 0x00, 0x60, 0x00, 0x80, 0x00, 0xA0, 0x00, 0xEB, 0x00
+	},	
+ 
+	/* GM_1_1 */
+	{
+		 0x14, 0xEC, 0x11, 0xC2, 0x10, 0x78, 0x0F, 0xB6, 0x0F, 0x2F, 0x0E, 0xB6,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x21, 0x00, 0x3C, 0xC0, 0x5F, 0xC0, 0x89, 0x00, 0xB7, 0x80, 0xEB, 0x00
+	},	
+ 
+	/* GM_1_2 */
+	{
+		 0x19, 0xD8, 0x13, 0x33, 0x10, 0xD2, 0x0F, 0x6D, 0x0E, 0x5E, 0x0D, 0xA4,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x25, 0x00, 0x43, 0x00, 0x66, 0xC0, 0x8F, 0x40, 0xBB, 0x40, 0xEB, 0x00
+	},	
+ 
+	/* GM_1_3 */
+	{
+		 0x1E, 0xC4, 0x14, 0x7A, 0x11, 0x0F, 0xF, 0x0C, 0x0D, 0xA1, 0x0C, 0xB6,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x29, 0x00, 0x49, 0x00, 0x6D, 0x40, 0x94, 0xC0, 0xBE, 0x80, 0xEB, 0x00
+	},	
+ 
+	/* GM_1_4 */
+	{
+		 0x24, 0x00, 0x15, 0x70, 0x11, 0x0F, 0x0E, 0xAA, 0x0D, 0x0F, 0x0B, 0xDB,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x2D, 0x40, 0x4E, 0xC0, 0x73, 0x00, 0x99, 0x80, 0xC1, 0x80, 0xEB, 0x00
+ 	},	
+ 
+	/* GM_1_5 */
+	{
+		 0x29, 0x3B, 0x16, 0x3D, 0x11, 0x0F, 0x0E, 0x30, 0x0C, 0x7D, 0x0B, 0x24,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x31, 0x80, 0x54, 0x40, 0x78, 0x80, 0x9D, 0xC0, 0xC4, 0x00, 0xEB, 0x00
+	},	
+ 
+	/* GM_1_6 */
+	{
+		 0x2E, 0x27, 0x17, 0x0A, 0x10, 0xD2, 0x0D, 0xE7, 0x0B, 0xEB, 0x0A, 0x80,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x35, 0x80, 0x59, 0x80, 0x7D, 0x40, 0xA1, 0xC0, 0xC6, 0x40, 0xEB, 0x00
+	},	
+ 
+	/* GM_1_7 */
+	{
+		 0x33, 0x62, 0x17, 0x5C, 0x10, 0xD2, 0x0D, 0x6D, 0x0B, 0x6D, 0x09, 0xED,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x39, 0xC0, 0x5E, 0x40, 0x82, 0x00, 0xA5, 0x40, 0xC8, 0x40, 0xEB, 0x00
+	},	
+ 
+	/* GM_1_8 */
+	{
+		 0x38, 0x4E, 0x17, 0xAE, 0x10, 0xB4, 0x0D, 0x0C, 0x0A, 0xF0, 0x09, 0x6D,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x3D, 0xC0, 0x62, 0xC0, 0x86, 0x40, 0xA8, 0x80, 0xCA, 0x00, 0xEB, 0x00
+	},	
+ 
+	/* GM_1_9 */
+	{
+		 0x3D, 0x3B, 0x18, 0x00, 0x10, 0x5A, 0x0C, 0xC3, 0x0A, 0x72, 0x09, 0x00,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x41, 0xC0, 0x67, 0x40, 0x8A, 0x00, 0xAB, 0x80, 0xCB, 0x80, 0xEB, 0x00
+	},	
+ 
+	/* GM_2_0 */
+	{
+		 0x41, 0xD8, 0x18, 0x28, 0x10, 0x3C, 0x0C, 0x49, 0x0A, 0x1F, 0x08, 0x92,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x45, 0x80, 0x6B, 0x40, 0x8D, 0xC0, 0xAE, 0x00, 0xCD, 0x00, 0xEB, 0x00
+	},	
+ 
+	/* GM_2_1 */
+	{
+		 0x46, 0x76, 0x18, 0x51, 0x0F, 0xE1, 0x0C, 0x00, 0x09, 0xB6, 0x08, 0x36,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x49, 0x40, 0x6F, 0x40, 0x91, 0x00, 0xB0, 0x80, 0xCE, 0x40, 0xEB, 0x00
+	},	
+ 
+	/* GM_2_2 */
+	{
+		 0x4A, 0xC4, 0x18, 0x7A, 0x0F, 0xA5, 0x0B, 0x9E, 0x09, 0x63, 0x07, 0xDB,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x4C, 0xC0, 0x73, 0x00, 0x94, 0x40, 0xB2, 0xC0, 0xCF, 0x80, 0xEB, 0x00
+	},	
+ 
+	/* GM_2_3 */
+	{
+		 0x4F, 0x13, 0x18, 0x51, 0x0F, 0x69, 0x0B, 0x6D, 0x09, 0x0F, 0x07, 0x80,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x50, 0x40, 0x76, 0x40, 0x97, 0x00, 0xB5, 0x00, 0xD0, 0xC0, 0xEB, 0x00
+	},	
+ 
+	/* GM_2_4 */
+	{
+		 0x53, 0x13, 0x18, 0x7A, 0x0F, 0x0F, 0x0B, 0x24, 0x08, 0xBC, 0x07, 0x36,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x53, 0x80, 0x79, 0xC0, 0x99, 0xC0, 0xB7, 0x00, 0xD1, 0xC0, 0xEB, 0x00
+	},	
+ 
+	/* GM_2_5 */
+	{
+		 0x57, 0x13, 0x18, 0x51, 0x0E, 0xF0, 0x0A, 0xC3, 0x08, 0x7D, 0x06, 0xED,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x56, 0xC0, 0x7C, 0xC0, 0x9C, 0x80, 0xB8, 0xC0, 0xD2, 0xC0, 0xEB, 0x00
+	},	
+ 
+	/* GM_2_6 */
+	{
+		 0x5B, 0x13, 0x18, 0x28, 0x0E, 0x96, 0x0A, 0x92, 0x08, 0x29, 0x06, 0xB6,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x5A, 0x00, 0x7F, 0xC0, 0x9E, 0xC0, 0xBA, 0x80, 0xD3, 0x80, 0xEB, 0x00
+	},	
+ 
+	/* GM_2_7 */
+	{
+		 0x5E, 0xC4, 0x18, 0x00, 0x0E, 0x78, 0x0A, 0x30, 0x08, 0x00, 0x06, 0x6D,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x5D, 0x00, 0x82, 0x80, 0xA1, 0x40, 0xBC, 0x00, 0xD4, 0x80, 0xEB, 0x00
+	},	
+ 
+	/* GM_2_8 */
+	{
+		 0x62, 0x76, 0x17, 0xD7, 0x0E, 0x1E, 0x0A, 0x00, 0x07, 0xC1, 0x06, 0x36,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x60, 0x00, 0x85, 0x40, 0xA3, 0x40, 0xBD, 0x80, 0xD5, 0x40, 0xEB, 0x00
+	},	
+ 
+	/* GM_2_9 */
+	{
+		 0x65, 0xD8, 0x17, 0xAE, 0x0D, 0xE1, 0x09, 0xCF, 0x07, 0x82, 0x06, 0x00,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x62, 0xC0, 0x87, 0xC0, 0xA5, 0x40, 0xBF, 0x00, 0xD6, 0x00, 0xEB, 0x00
+	},	
+ 
+	/* GM_3_0 */
+	{
+		 0x69, 0x3B, 0x17, 0x85, 0x0D, 0xA5, 0x09, 0x86, 0x07, 0x43, 0x05, 0xDB,
+		 0x10, 0x1D, 0x36, 0x58, 0x82, 0xB3, 0xEB,
+		 0x10, 0x00, 0x65, 0x80, 0x8A, 0x40, 0xA7, 0x40, 0xC0, 0x40, 0xD6, 0x80, 0xEB, 0x00
+	}
+};
+
+void __VISetTiming(u8 timing)
+{
+  __VIWriteI2CRegister8(0x00,timing);
+}
+
+void __VISetYUVSEL(u8 dtvstatus)
+{
+  u8 vdacFlagRegion = 0;
+  u32 currTvMode = _SHIFTR(_viReg[1],8,2);
+  if(currTvMode==VI_PAL || currTvMode==VI_EURGB60)
+    vdacFlagRegion = 2;
+	else if(currTvMode==VI_MPAL)
+    vdacFlagRegion = 1;
+
+	__VIWriteI2CRegister8(0x01, _SHIFTL(dtvstatus,5,3)|(vdacFlagRegion&0x1f)); 
+}
+
+void __VISetVBICtrl(u16 data)
+{
+	__VIWriteI2CRegister16(0x02, data);
+}
+
+void __VISetTrapFilter(u8 disable)
+{
+	if (disable)
+    __VIWriteI2CRegister8(0x03, 0);
+	else
+    __VIWriteI2CRegister8(0x03, 1);
+}
+
+void __VISet3in1Output(u8 enable)
+{
+  __VIWriteI2CRegister8(0x04,enable);
+}
+
+void __VISetCGMS(u16 value)
+{
+	__VIWriteI2CRegister16(0x05, value);
+}
+
+void __VISetWSS(u16 value)
+{
+	__VIWriteI2CRegister16(0x08, value);
+}
+
+void __VISetRGBOverDrive(u8 value)
+{
+  u32 currTvMode = _SHIFTR(_viReg[1],8,2);
+  if (currTvMode == VI_DEBUG)
+    __VIWriteI2CRegister8(0x0A,(value<<1)|1);
+  else
+    __VIWriteI2CRegister8(0x0A,0);
+}
+
+void __VISetOverSampling(void)
+{
+  __VIWriteI2CRegister8(0x65,1);
+}
+
+void __VISetCCSEL(void)
+{
+  __VIWriteI2CRegister8(0x6a,1);
+}
+
+void __VISetFilterEURGB60(u8 enable)
+{
+	__VIWriteI2CRegister8(0x6e, enable);
+}
+
+void __VISetVolume(u16 value)
+{
+  __VIWriteI2CRegister16(0x71,value);
+}
+
+void __VISetClosedCaption(u32 value)
+{
+	__VIWriteI2CRegister32(0x7a, value);
+}
+
+void __VISetGamma(VIGamma gamma)
+{
+  u8 *data = (u8 *)&gamma_coeffs[gamma][0];
+  __VIWriteI2CRegisterBuf(0x10, 0x21, data);
+}
+
+/* User Configurable */
+
+void VIDEO_SetGamma(VIGamma gamma)
+{
+  __VISetGamma(gamma);
+}
+
+void VIDEO_SetTrapFilter(bool enable)
+{
+  if (enable)
+    __VISetTrapFilter(0);
+  else
+    __VISetTrapFilter(1);
+}
+
+#endif
Index: source/gx/main.c
===================================================================
--- source/gx/main.c	(revision 440)
+++ source/gx/main.c	(revision 441)
@@ -29,6 +29,11 @@
 #include "aram.h"
 #include "dvd.h"
 
+#ifdef HW_RVL
+#include "usb2storage.h"
+#include "mload.h"
+#endif
+
 #include <fat.h>
 #include <ogc/cast.h>
 
@@ -39,14 +44,55 @@
 u32 Shutdown = 0;
 
 #ifdef HW_RVL
-
-/* Power Button callback */
+/****************************************************************************
+ * Power Button callback 
+ ***************************************************************************/
 static void Power_Off(void)
 {
   Shutdown = 1;
   ConfigRequested = 1;
 }
 
+/****************************************************************************
+ * IOS support
+ ***************************************************************************/
+static bool FindIOS(u32 ios)
+{
+	s32 ret;
+	u32 n;
+	
+  u64 *titles = NULL;
+	u32 num_titles=0;
+	
+	ret = ES_GetNumTitles(&num_titles);
+	if (ret < 0)
+		return false;
+	
+	if(num_titles < 1) 
+		return false;
+	
+	titles = (u64 *)memalign(32, num_titles * sizeof(u64) + 32);
+	if (!titles)
+		return false;
+	
+	ret = ES_GetTitles(titles, num_titles);
+	if (ret < 0)
+	{
+		free(titles);
+		return false;
+	}
+	
+	for(n=0; n < num_titles; n++)
+	{
+		if((titles[n] & 0xFFFFFFFF)==ios) 
+		{
+			free(titles); 
+			return true;
+		}
+	}
+  free(titles); 
+	return false;
+}
 #endif
 
 /***************************************************************************
@@ -113,7 +159,8 @@
 {
   /* cartridge hot-swap support */
   uint8 hotswap = 0;
-  if (cart.romsize) hotswap = config.hot_swap;
+  if (cart.romsize)
+    hotswap = config.hot_swap;
 
   /* Load ROM */
   cart.romsize = size;
@@ -157,6 +204,7 @@
   gx_video_Shutdown();
 #ifdef HW_RVL
   DI_Close();
+  mload_close();
 #endif
 }
 
@@ -170,14 +218,29 @@
 int main (int argc, char *argv[])
 {
 #ifdef HW_RVL
-  /* initialize DVDX */
+	/* try to load IOS 202 */
+	if(IOS_GetVersion() != 202 && FindIOS(202))
+		IOS_ReloadIOS(202);
+	
+	if(IOS_GetVersion() == 202)
+	{
+		/* disable DVDX stub */
+        DI_LoadDVDX(false);
+		
+		/* load EHCI module & enable USB2 driver */
+		if(mload_init() >= 0 && load_ehci_module())
+			USB2Enable(true);
+	}
+
+  /* initialize DVD driver */
   DI_Init();
 #endif
 
-  /* initialize hardware */
+  /* initialize video engine */
   gx_video_Init();
-  gx_input_Init();
+
 #ifdef HW_DOL
+  /* initialize DVD driver */
   DVD_Init ();
   dvd_drive_detect();
 #endif
@@ -185,7 +248,6 @@
   /* initialize FAT devices */
   if (fatInitDefault())
   {
-    /* check for default directories */
     DIR_ITER *dir = NULL;
 
     /* base directory */
@@ -195,29 +257,26 @@
     if (dir == NULL) mkdir(pathname,S_IRWXU);
     else dirclose(dir);
 
-    /* SRAM & Savestate files directory */ 
+    /* default SRAM & Savestate files directory */ 
     sprintf (pathname, "%s/saves",DEFAULT_PATH);
     dir = diropen(pathname);
     if (dir == NULL) mkdir(pathname,S_IRWXU);
     else dirclose(dir);
 
-    /* Snapshot files directory */ 
+    /* default Snapshot files directory */ 
     sprintf (pathname, "%s/snaps",DEFAULT_PATH);
     dir = diropen(pathname);
     if (dir == NULL) mkdir(pathname,S_IRWXU);
     else dirclose(dir);
-
-    /* Cheat files directory */ 
-    sprintf (pathname, "%s/cheats",DEFAULT_PATH);
-    dir = diropen(pathname);
-    if (dir == NULL) mkdir(pathname,S_IRWXU);
-    else dirclose(dir);
   }
 
-  /* initialize sound engine */
+  /* initialize input engine */
+  gx_input_Init();
+
+  /* initialize sound engine (need libfat) */
   gx_audio_Init();
 
-  /* initialize core engine */
+  /* initialize genesis plus core */
   legal();
   config_default();
   history_default();
Index: Makefile.wii
===================================================================
--- Makefile.wii	(revision 440)
+++ Makefile.wii	(revision 441)
@@ -18,9 +18,10 @@
 TARGET		:=	genplus_wii
 BUILD		:=	build_wii
 SOURCES		:=	source source/m68k source/z80 source/sound source/ntsc source/cart_hw source/cart_hw/svp \
-			source/gx source/gx/gui source/gx/fileio source/gx/images source/gx/sounds
+			source/gx source/gx/utils source/gx/gui source/gx/fileio source/gx/images source/gx/sounds
 INCLUDES	:=	source source/m68k source/z80 source/sound source/ntsc source/cart_hw source/cart_hw/svp \
-			build_wii source/gx source/gx/gui source/gx/fileio source/gx/images source/gx/sounds
+			source/gx source/gx/utils source/gx/gui source/gx/fileio source/gx/images source/gx/sounds \
+			$(BUILD) 
 
 #---------------------------------------------------------------------------------
 # options for code generation
@@ -80,7 +81,8 @@
 export OFILES	:=	$(addsuffix .o,$(BINFILES)) \
 			$(PNGFILES:.png=.png.o) $(PCMFILES:.pcm=.pcm.o) $(OGGFILES:.ogg=.ogg.o) \
 			$(CPPFILES:.cpp=.o) $(CFILES:.c=.o) \
-			$(sFILES:.s=.o) $(SFILES:.S=.o)
+			$(sFILES:.s=.o) $(SFILES:.S=.o) \
+			$(CURDIR)/source/gx/utils/ehcmodule.elf.o
 
 #---------------------------------------------------------------------------------
 # build a list of include paths
Index: Makefile.gc
===================================================================
--- Makefile.gc	(revision 440)
+++ Makefile.gc	(revision 441)
@@ -18,9 +18,10 @@
 TARGET		:=	genplus_cube
 BUILD		:=	build_cube
 SOURCES		:=	source source/m68k source/z80 source/sound source/ntsc source/cart_hw source/cart_hw/svp \
-			source/gx source/gx/gui source/gx/fileio source/gx/images source/gx/sounds
+			source/gx source/gx/utils source/gx/gui source/gx/fileio source/gx/images source/gx/sounds
 INCLUDES	:=	source source/m68k source/z80 source/sound source/ntsc source/cart_hw source/cart_hw/svp \
-			build_cube source/gx source/gx/gui source/gx/fileio source/gx/images source/gx/sounds
+			source/gx source/gx/utils source/gx/gui source/gx/fileio source/gx/images source/gx/sounds \
+			$(BUILD)
 
 #---------------------------------------------------------------------------------
 # options for code generation
